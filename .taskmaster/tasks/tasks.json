{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "YAML Config Loader and Validation System",
        "description": "Implement the core configuration system to load, validate, and provide immutable runtime access to game balance parameters.",
        "details": "Create `src/config/loader.ts` and `src/config/schema.ts`. Use a library like `js-yaml` to parse the YAML file and `zod` or `ajv` for schema validation. Ensure the config object is deeply frozen (`Object.freeze`) once loaded to maintain immutability. Parameters include player name rules, NPC density, cycle timers, and bite ranges. \n\n```typescript\n// Pseudo-code snippet\nexport const loadConfig = async (path: string) => {\n  const raw = await fetch(path).then(res => res.text());\n  const data = yaml.load(raw);\n  const validated = ConfigSchema.parse(data);\n  return Object.freeze(validated);\n};\n```",
        "testStrategy": "Unit tests to verify: 1. Successful loading of valid YAML. 2. Validation errors for missing/invalid fields. 3. Proper application of default values. 4. Immutability of the returned object.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Game Configuration Schema and Types",
            "description": "Create a comprehensive Zod schema in src/config/schema.ts for all game balance parameters.",
            "dependencies": [],
            "details": "Implement the schema using Zod to define player name rules, NPC density, cycle timers, and bite ranges. Ensure it includes default values and exports TypeScript types for use throughout the application.",
            "status": "done",
            "testStrategy": "Validate that the Zod schema correctly rejects invalid types and successfully parses a full object of default values.",
            "updatedAt": "2026-02-04T18:01:06.003Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement YAML Loader with Immutability",
            "description": "Develop the logic in src/config/loader.ts to fetch, parse, and freeze the configuration.",
            "dependencies": [
              1
            ],
            "details": "Use js-yaml to parse raw text into JavaScript objects. Implement a utility to deeply freeze the resulting object after Zod validation to ensure the configuration remains immutable during runtime.",
            "status": "done",
            "testStrategy": "Unit tests to verify that the loader returns a deeply frozen object and that attempts to modify it throw errors in strict mode.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T18:08:45.379Z"
          },
          {
            "id": 3,
            "title": "Validation and Human-Friendly Error Reporting",
            "description": "Implement an error handling wrapper to provide clear feedback when configuration files are malformed or invalid.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create a utility to catch Zod validation errors and format them into readable strings. Instead of raw schema errors, show specific messages indicating which field in the YAML file is incorrect and why.",
            "status": "done",
            "testStrategy": "Inject invalid YAML structures and verify that the console/logs output descriptive errors that would allow a designer to fix the file.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T18:09:23.813Z"
          },
          {
            "id": 4,
            "title": "Create Sample Configs and Integration Tests",
            "description": "Provide baseline configuration files and perform full system integration testing of the loader.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create assets/config/default.yaml containing standard game balance. Write integration tests that simulate fetching this file, validating it, and checking the resulting object against expected values.",
            "status": "done",
            "testStrategy": "Execute a full test suite checking: 1. Successful loading. 2. Default value application. 3. Handling of missing files. 4. Handling of invalid YAML syntax.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T18:13:42.537Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down the YAML config loader into: 1. Schema definition using Zod for all game parameters. 2. Implementation of the loader with file system/fetch logic. 3. Unit tests for validation and immutability.",
        "updatedAt": "2026-02-04T18:13:42.537Z"
      },
      {
        "id": 2,
        "title": "Design System Tokens and Color Roles",
        "description": "Establish the foundational UI tokens and color roles for consistent styling across all screens and components.",
        "details": "Implement `src/ui/tokens.ts` defining spacing, typography, radii, and color palettes (e.g., semantic roles like 'danger', 'stealth-active', 'sun-warning'). These tokens must be used by all subsequent UI components. \n\n```typescript\nexport const TOKENS = {\n  colors: { primary: '#6200ee', sunDamage: '#ffeb3b', panic: '#f44336' },\n  spacing: { sm: 4, md: 8, lg: 16 },\n  radius: { default: 4 }\n};\n```",
        "testStrategy": "Visual verification that CSS variables or JS constants match the design specs. Automated linting check to ensure no hardcoded hex colors are used in UI files.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Core UI Tokens and Semantic Color Roles",
            "description": "Create the src/ui/tokens.ts file to store all foundational design constants including spacing, typography, radii, and semantic color palettes.",
            "dependencies": [],
            "details": "Implement the TOKENS object containing colors (primary, sunDamage, panic, danger, stealth-active, sun-warning), spacing (sm, md, lg), and radius. Use TypeScript interfaces to ensure type safety for all design constants.",
            "status": "done",
            "testStrategy": "Manual verification of the object structure and unit tests to ensure all required token keys are exported and values match design specifications.",
            "updatedAt": "2026-02-04T18:20:29.326Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Token Enforcement Utility and Linting Check",
            "description": "Create a mechanism to ensure developers use the defined tokens instead of hardcoded hex values or raw pixel numbers in UI components.",
            "dependencies": [
              1
            ],
            "details": "Develop a helper function or custom theme provider to access tokens. Configure an ESLint rule or provide a script to scan src/ui/ for hardcoded hex colors or direct numerical spacing values to enforce token usage.",
            "status": "done",
            "testStrategy": "Run an automated linting check against a test component containing hardcoded colors to confirm the enforcement mechanism identifies violations.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T18:21:49.011Z"
          }
        ],
        "complexity": 2,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Split this into: 1. Definition of the token object structure. 2. Implementation of a linting rule or helper function to enforce token usage in UI components.",
        "updatedAt": "2026-02-04T18:21:49.011Z"
      },
      {
        "id": 3,
        "title": "Pathfinding and Sun-Shade Map Systems",
        "description": "Implement the spatial logic for NPC/Player movement and detection of sunlit versus shaded areas.",
        "details": "Create `src/systems/pathfinding.ts` using Phaser's built-in A* or a custom grid-based pathfinder. Implement `src/systems/sun-shade-map.ts` which takes a tilemap and identifies 'safe' zones (interiors, shadows) versus 'danger' zones based on time of day. This will use the runtime config for damage intervals.",
        "testStrategy": "Integration tests: 1. Pathfinding returns valid paths around obstacles. 2. Sun-Shade map correctly identifies a tile as 'shaded' when under a building or during night.",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Grid-Based Pathfinding System",
            "description": "Develop the core pathfinding logic in src/systems/pathfinding.ts using A* to enable NPC and player movement.",
            "dependencies": [],
            "details": "Integrate Phaser's navigation capabilities or an A* library to calculate paths across the tilemap. Map tile collisions and 'unwalkable' properties to the pathfinder grid.",
            "status": "done",
            "testStrategy": "Unit test: Verify that the pathfinding algorithm returns a valid list of coordinates between two points and correctly avoids collision tiles.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T18:32:51.101Z"
          },
          {
            "id": 2,
            "title": "Develop Sun-Shade Mapping Logic",
            "description": "Create src/systems/sun-shade-map.ts to differentiate between sunlit and shaded tilemap areas.",
            "dependencies": [],
            "details": "Iterate through the tilemap layers to identify tiles marked as 'interior' or 'shadow' based on metadata. Define a boolean mask for the current level's safety zones.",
            "status": "done",
            "testStrategy": "Integration test: Confirm that tiles located under building sprites or inside designated interior layers are flagged as 'safe' zones.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T18:37:40.315Z"
          },
          {
            "id": 3,
            "title": "Integrate Dynamic Safe Zone Transitions",
            "description": "Sync the sun-shade map with the Day/Night Cycle controller to update safety status in real-time.",
            "dependencies": [
              2
            ],
            "details": "Listen for Phase events from the Day/Night controller. Adjust the sun-shade map so that all outdoor tiles become 'safe' during Night and 'danger' during Day, with transitions at Dawn/Dusk.",
            "status": "done",
            "testStrategy": "Integration test: Simulate a cycle transition and verify that the safety status of a specific outdoor tile changes when the phase moves from Day to Night.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T18:40:11.198Z"
          },
          {
            "id": 4,
            "title": "Optimize and Profile Tilemap Scanning",
            "description": "Perform performance profiling on the spatial logic systems to ensure smooth execution on mobile devices.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Profile the frequency of map-wide updates using Chrome DevTools. Implement optimizations such as caching safe-zone results or using bitwise operations for grid scanning to maintain 60 FPS.",
            "status": "done",
            "testStrategy": "Performance test: Measure the execution time of the sun-shade update logic to ensure it stays below the 16ms frame budget during scene updates.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T18:41:08.763Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Separate the spatial logic into: 1. Integration of Phaser A* for NPC movement. 2. Implementation of the sun-shade mapping logic (tile-based shadow detection). 3. Dynamic updating of safe zones based on the game clock. 4. Performance profiling for tilemap scanning.",
        "updatedAt": "2026-02-04T18:41:08.763Z"
      },
      {
        "id": 4,
        "title": "Day/Night Cycle Controller",
        "description": "Implement the logic for transitioning between Day, Dusk, Night, and Dawn phases.",
        "details": "Create `src/controllers/day-night.ts`. It should manage a global timer and update the current 'Phase'. It triggers events that other systems (like NPC density or Police Response) listen to. Transitions should provide visual warnings (Dusk/Dawn) as per PRD.",
        "testStrategy": "Unit tests for state transitions: Day -> Dusk -> Night -> Dawn -> Day. Verify multipliers for NPC density are correctly calculated based on the active phase.",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Core Time Progression and Phase State Machine",
            "description": "Implement the fundamental time-tracking logic and state transitions for the cycle.",
            "dependencies": [],
            "details": "Develop the internal clock and state machine in src/controllers/day-night.ts to manage transitions between Day, Dusk, Night, and Dawn phases based on a configurable global timer.",
            "status": "done",
            "testStrategy": "Unit tests to verify that the internal clock correctly triggers phase transitions at designated intervals (e.g., Day -> Dusk).",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T18:46:08.490Z"
          },
          {
            "id": 2,
            "title": "Phase Transition Event Emitter System",
            "description": "Create a robust event-driven architecture for notifying external systems of cycle changes.",
            "dependencies": [
              1
            ],
            "details": "Implement an EventEmitter within the controller to broadcast 'phaseChange' signals. This allows systems like the UI, NPC Manager, and Police Response to react dynamically to time changes.",
            "status": "done",
            "testStrategy": "Integration tests using mock listeners to confirm that events are emitted with the correct phase data exactly when a transition occurs.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:02:02.160Z"
          },
          {
            "id": 3,
            "title": "NPC Density and Police Multiplier Logic",
            "description": "Calculate and expose environmental modifiers based on the active cycle phase.",
            "dependencies": [
              1
            ],
            "details": "Implement getter methods or data structures that provide multipliers for NPC density and police aggression levels tailored to each phase (e.g., lower NPC density during Night, higher police presence during Day).",
            "status": "done",
            "testStrategy": "Validation tests to ensure that the getDensityMultiplier() and getPoliceMultiplier() methods return the values defined in the game configuration for each state.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:04:32.477Z"
          },
          {
            "id": 4,
            "title": "Scene FX and UI Warning Integration",
            "description": "Connect the controller to the visual systems to provide visual feedback and warnings.",
            "dependencies": [
              1,
              2
            ],
            "details": "Integrate the controller with the rendering engine to adjust global lighting (FX) and trigger 'Dusk/Dawn' warning UI components to alert players of impending environmental changes.",
            "status": "done",
            "testStrategy": "Manual verification in-game to observe smooth lighting transitions and the correct display of warning banners during the transitional Dusk and Dawn phases.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:06:23.760Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Divide the controller into: 1. Core state machine for cycle phases. 2. Event emitter system for phase transitions. 3. NPC density multiplier calculator based on the current phase.",
        "updatedAt": "2026-02-04T19:06:23.760Z"
      },
      {
        "id": 5,
        "title": "Panic Bubble and Police Response Logic",
        "description": "Develop the local panic mechanics and the resulting police spawning system.",
        "details": "Implement `src/controllers/panic-bubble.ts` to manage circular areas of effect around incidents. Implement `src/controllers/police-response.ts` to spawn police NPCs within or near the panic bubble. Use config for bubble radius, duration, and the 'night x2' multiplier for police response density.",
        "testStrategy": "Simulate an incident and verify: 1. Panic state only spreads to NPCs within the radius. 2. Police spawn count increases correctly during Night phase vs Day phase.",
        "priority": "medium",
        "dependencies": [
          "1",
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Panic Bubble Lifecycle and State Management",
            "description": "Create the core manager for panic bubbles, handling their creation, duration-based expiration, and spatial tracking.",
            "dependencies": [],
            "details": "Implement the PanicBubbleManager in src/controllers/panic-bubble.ts. It should store a collection of active bubbles (x, y, radius, remainingDuration) and include a cleanup loop to remove expired bubbles.",
            "status": "done",
            "testStrategy": "Unit test to verify that adding a bubble with a 5-second duration results in its removal from the active state after exactly 5 seconds.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:16:20.826Z"
          },
          {
            "id": 2,
            "title": "Develop AoE Logic for NPC Panic State Spread",
            "description": "Develop the spatial logic to detect NPCs within the radius of active bubbles and update their behavior state.",
            "dependencies": [
              1
            ],
            "details": "Implement a collision or distance-check routine that iterates through active bubbles and identifies all NPCs within the radius. Trigger the 'panic' state on the NPC instances to modify their movement speed or pathing.",
            "status": "done",
            "testStrategy": "Integration test: Place an NPC at distance R-1 and another at R+1 from the bubble center; verify only the first NPC enters the panic state.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:17:13.210Z"
          },
          {
            "id": 3,
            "title": "Implement Police Spawning Controller and Location Logic",
            "description": "Create the spawning system that generates police NPCs at valid locations near or within panic bubbles.",
            "dependencies": [
              1
            ],
            "details": "Implement src/controllers/police-response.ts. This controller must query the map for valid, walkable tiles near the panic bubble center and instantiate Police NPC objects at a rate defined by the config.",
            "status": "done",
            "testStrategy": "Verify that police NPCs are instantiated at coordinates within 20% of the bubble radius and that they are placed on valid navigation tiles.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:18:31.042Z"
          },
          {
            "id": 4,
            "title": "Integrate Night-time Multiplier and Config Parameters",
            "description": "Adjust police spawn density and frequency based on the global configuration and current day/night phase.",
            "dependencies": [
              3
            ],
            "details": "Access the global YAML configuration for base spawn rates and radius. Implement logic to double (x2) the spawn density when the current game state is set to 'Night' phase.",
            "status": "done",
            "testStrategy": "Manual test: Trigger a panic bubble during the Day phase and count spawns, then repeat during the Night phase to confirm the count is exactly doubled.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:19:27.908Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Detail the panic mechanics: 1. Area-of-effect (AoE) logic for panic spread. 2. Police spawn algorithm (location selection and frequency). 3. State management for active bubbles. 4. Night-time multiplier implementation.",
        "updatedAt": "2026-02-04T19:19:27.908Z"
      },
      {
        "id": 6,
        "title": "One-Handed Tap-to-Move and Stealth Interaction",
        "description": "Implement the primary mobile control scheme for movement, target selection, and feeding.",
        "details": "Create the input handling logic in a base player class. Tapping empty space moves the player. Tapping an NPC selects them as a target (showing a TargetRingFlash). Tapping the target again while in range initiates the 'Bite' (feeding) action. All timings and ranges must come from `RuntimeConfig`.",
        "testStrategy": "Manual testing in mobile emulator: 1. Tap to move works. 2. NPC selection/deselection via tap works. 3. Feeding logic triggers correctly when within the YAML-defined range.",
        "priority": "high",
        "dependencies": [
          "1",
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Tap-to-Move Input Handler",
            "description": "Handle screen taps on empty tiles to calculate paths and initiate player movement using the pathfinding system.",
            "dependencies": [],
            "details": "Integrate with the pathfinding system created in Task 3. On screen tap, convert pointer coordinates to tile coordinates and request a path for the player character. Movement speed must be fetched from the RuntimeConfig loaded in Task 1.",
            "status": "done",
            "testStrategy": "Manual testing in emulator: confirm player moves to the tapped location and correctly navigates around static obstacles.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:20:59.919Z"
          },
          {
            "id": 2,
            "title": "Develop NPC Selection and Targeting Logic",
            "description": "Differentiate between movement taps and NPC interaction taps to manage the current active target.",
            "dependencies": [
              1
            ],
            "details": "Implement a hit-detection check on input. If an NPC sprite is tapped, set that NPC as the active target. If the ground is tapped, trigger movement instead. Selection must be stored in the base player class to allow for subsequent interaction checks.",
            "status": "done",
            "testStrategy": "Verify that tapping an NPC sets them as target and tapping a different NPC updates the target, while tapping empty space clears it or triggers movement.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:22:48.515Z"
          },
          {
            "id": 3,
            "title": "Create 'Bite' Action State Machine",
            "description": "Implement the logic for the feeding interaction, including range verification and state transitions.",
            "dependencies": [
              2
            ],
            "details": "Define a state machine for the feeding interaction. When the active target is tapped again, check if the distance to the NPC is within the 'biteRange' defined in RuntimeConfig. If within range, transition to the feeding state and trigger the relevant game logic.",
            "status": "done",
            "testStrategy": "Unit test distance check logic; manual test to ensure 'Bite' action only triggers when the player is sufficiently close to the selected NPC.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:23:41.743Z"
          },
          {
            "id": 4,
            "title": "Implement TargetRingFlash Visual Feedback",
            "description": "Create and manage the visual indicator that appears when an NPC is selected or interacted with.",
            "dependencies": [
              2
            ],
            "details": "Create a reusable TargetRingFlash graphic that attaches to the selected NPC's position. This visual must update its visibility based on the selection state and play a specific animation (flash or pulse) when the feeding interaction begins.",
            "status": "done",
            "testStrategy": "Visual inspection: Ensure the ring correctly follows the NPC and plays its animation during the selection and bite phases.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:24:25.824Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down the mobile controls into: 1. Tap-to-move input handler with pathfinder integration. 2. NPC selection/targeting logic (tap vs. movement). 3. The 'Bite' action state machine and range checking. 4. Visual feedback (TargetRingFlash) implementation.",
        "updatedAt": "2026-02-04T19:24:25.824Z"
      },
      {
        "id": 7,
        "title": "Town Scene: Core World Implementation",
        "description": "Assemble the primary game world (Town) with NPCs, tilemaps, and active controllers.",
        "details": "Implement `src/scenes/town.ts`. Integrate the Tilemap, Player character, NPC pooling, and the DayNight/Panic/Police controllers. This scene acts as the main gameplay loop container where 'move -> bite -> panic -> escape' occurs.",
        "testStrategy": "Playtest the full loop: Start in town, find NPC, bite, trigger panic bubble, observe police spawning, and escape to a safe zone.",
        "priority": "high",
        "dependencies": [
          "4",
          "5",
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Town Scene Lifecycle and Asset Initialization",
            "description": "Establish the foundational structure of the Town scene and load necessary graphical assets for the environment.",
            "dependencies": [],
            "details": "Implement the preload() and create() methods in src/scenes/town.ts. Load the Tiled JSON map, tilesets, and sprite sheets for the player and NPCs. Ensure the camera is initialized to follow the player character.",
            "status": "done",
            "testStrategy": "Verify that the game loads without errors and the town tilemap is rendered correctly in the browser.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:26:36.592Z"
          },
          {
            "id": 2,
            "title": "NPC Pool Integration and Spawning Logic",
            "description": "Integrate the NPC pooling system into the Town scene to manage entity lifecycles efficiently.",
            "dependencies": [
              1
            ],
            "details": "Initialize the NPC pool within the Town scene. Implement a spawning algorithm that places NPCs on walkable tilemap coordinates, respecting the density multipliers provided by the Day/Night controller.",
            "status": "done",
            "testStrategy": "Observe that NPCs are spawned upon scene start and that the number of NPCs matches the expected density for the current time phase.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:28:51.189Z"
          },
          {
            "id": 3,
            "title": "System Orchestration and Event Bus Setup",
            "description": "Connect the Day/Night, Panic, and Police controllers to the Town scene's update loop.",
            "dependencies": [
              1
            ],
            "details": "Instantiate the DayNightController, PanicController, and PoliceController. Set up event listeners within the scene to handle phase shifts (e.g., changing ambient light) and panic escalations (e.g., triggering police spawns).",
            "status": "done",
            "testStrategy": "Trigger a simulated phase change via the console and verify that the scene's ambient tint and NPC behavior update accordingly.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:29:33.738Z"
          },
          {
            "id": 4,
            "title": "Physics Collision and Interaction Layer Configuration",
            "description": "Configure the physics engine to handle collisions between the player, tilemap obstacles, and NPCs.",
            "dependencies": [
              1,
              2
            ],
            "details": "Set up Phaser Arcade Physics or Matter.js to handle collisions with the 'Obstacles' layer of the tilemap. Implement trigger zones for the 'Bite' mechanic and ensure the player cannot pass through buildings or scene boundaries.",
            "status": "done",
            "testStrategy": "Perform manual movement tests to ensure the player character is blocked by walls and can trigger interaction prompts when near NPCs.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:30:10.743Z"
          },
          {
            "id": 5,
            "title": "Debug Overlay and Spatial System Validation",
            "description": "Implement a debug toggle to visualize spatial systems, pathfinding nodes, and collision boundaries.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create a UI overlay that renders physics bodies, NPC detection radii, and current controller states (Time, Panic Level, Active Police Count). This will be used for balancing the 'move -> bite -> escape' gameplay loop.",
            "status": "done",
            "testStrategy": "Toggle the debug view and confirm that collision boxes align with visual assets and that NPC state labels update in real-time.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:30:48.177Z"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Structure the core scene implementation: 1. Scene lifecycle management and asset loading. 2. Integration of NPC pooling for performance. 3. Controller orchestration (Day/Night, Panic, Police). 4. Player-world collision and interaction setup. 5. Debug overlay for spatial systems.",
        "updatedAt": "2026-02-04T19:30:48.177Z"
      },
      {
        "id": 8,
        "title": "Interior and Castle Scenes with Respawn Logic",
        "description": "Implement secondary scenes and the transition logic between them, including the death/respawn flow.",
        "details": "Create `src/scenes/interior.ts` and `src/scenes/castle.ts`. The Castle serves as the safe-zone/respawn point. Use a scene manager to handle transitions. If health reaches zero in the Town or Sun, the player must respawn in the Castle scene.",
        "testStrategy": "Verify scene transitions: 1. Entering a building switches to InteriorScene. 2. Dying in Town correctly triggers transition to CastleScene.",
        "priority": "medium",
        "dependencies": [
          "7"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Scene Transition Manager and State Persistence",
            "description": "Create a centralized manager to handle scene switching and data preservation between map segments.",
            "dependencies": [],
            "details": "Develop a utility to wrap Phaser's Scene Manager to pass player state (health, inventory) between Town, Interior, and Castle scenes efficiently.",
            "status": "done",
            "testStrategy": "Verify that player health values and state variables remain consistent when moving from the Town scene to an Interior scene and back.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:34:30.869Z"
          },
          {
            "id": 2,
            "title": "Create Interior and Castle Scene Classes with Tilemap Support",
            "description": "Implement the specific Scene classes for building interiors and the central castle safe-zone.",
            "dependencies": [
              1
            ],
            "details": "Construct src/scenes/interior.ts and src/scenes/castle.ts. Set up tilemap loading, collision layers, and exit portals that trigger the Scene Manager to return to the Town.",
            "status": "done",
            "testStrategy": "Manually trigger scene transitions via portal overlaps and confirm the correct Tiled assets are rendered for both the Castle and building interiors.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:36:33.828Z"
          },
          {
            "id": 3,
            "title": "Develop Death and Respawn Flow to Castle Scene",
            "description": "Implement the gameplay logic to trigger a respawn in the Castle when health reaches zero.",
            "dependencies": [
              1,
              2
            ],
            "details": "Add a listener to the player state for health reaching 0. Upon death, trigger a fade-out animation and invoke the Scene Manager to move the player to the Castle spawn coordinates.",
            "status": "done",
            "testStrategy": "Simulate player death in the Town scene by reducing health to zero and confirm the game successfully reloads the player at the designated Castle spawn point with reset health.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:37:11.423Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Expand into: 1. Scene transition manager for handling data persistence between scenes. 2. Implementation of Interior and Castle tilemap logic. 3. Death and Respawn flow (Health 0 -> Castle transition).",
        "updatedAt": "2026-02-04T19:37:11.423Z"
      },
      {
        "id": 9,
        "title": "UI Components and Game Overlays (S1-S9 HUD)",
        "description": "Create the Design System-based UI components and in-game overlays like the Blood bar, Phase indicator, and Panic flash.",
        "details": "Implement components in `src/ui/components/` and `src/ui/overlays/`. Include `BottomActionBar`, `TimeOfDayIndicator`, and full-screen flashes for damage/panic. These must use the tokens defined in Task 2. Use Phaser DOM elements or React/Vue overlay if specified by the stack.",
        "testStrategy": "Visual check: 1. UI elements scale for mobile portrait. 2. Phase indicator updates when Day/Night controller changes state. 3. Panic overlay flashes when the player is in a Panic Bubble.",
        "priority": "medium",
        "dependencies": [
          "2",
          "7"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Dynamic Blood Bar and Player Status Component",
            "description": "Create a UI component that visually represents the player's current blood and health levels using design system tokens.",
            "dependencies": [],
            "details": "Implement in `src/ui/components/BloodBar.ts`. Use `TOKENS.colors` for health states (e.g., critical, caution, healthy). The component must support smooth value transitions and scale for high-density mobile displays.",
            "status": "done",
            "testStrategy": "Unit test using a mock player state; verify that the bar width and color accurately reflect percentage thresholds from 0 to 100.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:42:17.015Z"
          },
          {
            "id": 2,
            "title": "Create Phase Indicator Linked to Day/Night Controller",
            "description": "Develop the TimeOfDayIndicator component that updates based on the global game cycle phase.",
            "dependencies": [],
            "details": "Implement in `src/ui/components/PhaseIndicator.ts`. This component must subscribe to the state of the Day/Night controller from Task 4 and display the current phase (Day, Dusk, Night, Dawn) using relevant icons and labels.",
            "status": "done",
            "testStrategy": "Integration test: manually trigger phase transitions in the controller and confirm the UI label and icon update immediately.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:42:54.437Z"
          },
          {
            "id": 3,
            "title": "Implement Full-Screen Damage and Panic Flash Overlays",
            "description": "Develop visual feedback overlays that trigger on damage or when entering panic zones.",
            "dependencies": [],
            "details": "Create `src/ui/overlays/FlashOverlay.ts`. Implement a full-screen alpha-rect or shader that flashes 'panic' red or 'sun damage' yellow when specific events are fired from the game engine.",
            "status": "done",
            "testStrategy": "Visual verification: trigger the panic event in-game and ensure the screen-wide flash occurs without obstructing UI controls.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:43:29.743Z"
          },
          {
            "id": 4,
            "title": "Assemble Responsive HUD Layout and Action Bar",
            "description": "Combine components into a cohesive HUD layout optimized for mobile portrait orientation.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Implement the main HUD container in `src/ui/HUDContainer.ts`. Include the `BottomActionBar` and use a layout system (CSS Flexbox or Phaser DOM) to ensure components are positioned correctly within mobile safe areas.",
            "status": "done",
            "testStrategy": "Responsiveness check: Verify that the HUD layout scales correctly across multiple mobile device aspect ratios (e.g., iPhone SE vs iPhone 14 Pro Max).",
            "parentId": "undefined",
            "updatedAt": "2026-02-05T08:04:21.167Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down the HUD: 1. Dynamic Blood Bar component. 2. Phase indicator linked to the Day/Night controller. 3. Full-screen damage/panic flash effects. 4. Responsive layout system for mobile portrait mode.",
        "updatedAt": "2026-02-05T08:04:21.167Z"
      },
      {
        "id": 10,
        "title": "Navigation and Screen Management (S0-S10)",
        "description": "Implement the complete set of screens (Main Menu, Settings, Game Over) and the navigation flow.",
        "details": "Implement the remaining screens (S0: Splash, S1: Main Menu, S10: Settings, etc.). Create a navigation controller that handles transitions between menus and scenes. Ensure the player name validation rules (Task 1) are applied on the profile/start screen.",
        "testStrategy": "End-to-End test: Boot the game, navigate from Splash to Main Menu, enter Settings, return, start game, trigger Game Over, and return to Menu.",
        "priority": "medium",
        "dependencies": [
          "1",
          "9"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Centralized Navigation Controller and Screen Router",
            "description": "Implement the core navigation manager to handle screen transitions, stack management, and scene switching for screens S0-S10.",
            "dependencies": [],
            "details": "Create a NavigationController class that maintains a screen stack. Implement logic to switch between Phaser scenes or UI layers, including fade-in/out transitions and state preservation for active scenes.",
            "status": "done",
            "testStrategy": "Unit test the router's stack logic to ensure push/pop operations maintain correct hierarchy and scene events are dispatched.",
            "parentId": "undefined",
            "updatedAt": "2026-02-05T08:16:20.984Z"
          },
          {
            "id": 2,
            "title": "UI Implementation for Splash, Main Menu, and Settings Screens",
            "description": "Develop the visual layouts for S0 (Splash), S1 (Main Menu), and S10 (Settings) using the project design tokens.",
            "dependencies": [
              1
            ],
            "details": "Build the screens using UI tokens from Task 2. Integrate the player name validation logic (Task 1) into the profile section. Ensure the Settings screen correctly interacts with the GameConfig/RuntimeConfig.",
            "status": "done",
            "testStrategy": "Manual visual verification against design specs and automated validation check to ensure name input rejects invalid strings.",
            "parentId": "undefined",
            "updatedAt": "2026-02-05T08:17:19.065Z"
          },
          {
            "id": 3,
            "title": "Input Handling, State Persistence, and Smoke Testing",
            "description": "Implement global back-button handling, settings persistence, and perform full-flow integration tests.",
            "dependencies": [
              1,
              2
            ],
            "details": "Map hardware back-button inputs to navigation 'pop' events. Implement local storage persistence for user settings. Execute an end-to-end smoke test covering the flow: Splash -> Menu -> Settings -> Game -> Game Over.",
            "status": "done",
            "testStrategy": "End-to-End test: Verify that navigating through the entire screen flow and returning to the menu works without memory leaks or state corruption.",
            "parentId": "undefined",
            "updatedAt": "2026-02-05T08:18:07.414Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Detail the menu flow: 1. Centralized navigation controller/router. 2. Implementation of Splash, Main, and Settings screens. 3. Validation logic for player names based on YAML config.",
        "updatedAt": "2026-02-05T08:18:07.414Z"
      },
      {
        "id": 11,
        "title": "Local Run / Demo Build Harness",
        "description": "Enable local dev and demo build for running the game.",
        "details": "Add a minimal bootstrapping entrypoint (e.g., src/main.ts) that creates the Phaser game instance and wires initial scenes/navigation. Add a local dev server and build/preview scripts (e.g., Vite). Add index.html container and document run/build steps in README. Ensure config loader and design tokens are integrated at boot.",
        "testStrategy": "Smoke test: run dev server, confirm game boots to splash/menu; run build/preview and confirm a playable demo loads without console errors.",
        "priority": "medium",
        "dependencies": [
          "10"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Setup Vite Build System and index.html",
            "description": "Configure the local development environment and build pipeline using Vite.",
            "dependencies": [],
            "details": "Install Vite as a dev dependency. Create a root 'index.html' that includes a container element for the Phaser canvas and scripts for 'src/main.ts'. Update 'package.json' with 'dev', 'build', and 'preview' commands to facilitate rapid development and demo packaging.",
            "status": "done",
            "testStrategy": "Verify that 'npm run dev' successfully launches a browser tab and 'npm run build' generates a 'dist' folder without errors.",
            "parentId": "undefined",
            "updatedAt": "2026-02-05T08:41:00.279Z"
          },
          {
            "id": 2,
            "title": "Implement Phaser Main Entrypoint and Configuration Bootstrapping",
            "description": "Create the primary bootstrapping logic in src/main.ts to initialize the game and load global configurations.",
            "dependencies": [
              1
            ],
            "details": "Implement 'src/main.ts' to invoke the YAML config loader (Task 1) and register Design System Tokens (Task 2). Initialize the Phaser.Game instance with appropriate configuration (physics, scaling, rendering). Wire the first scene provided by the Navigation Controller (Task 10).",
            "status": "done",
            "testStrategy": "Check the browser console during startup to ensure the frozen config object is loaded and design tokens are applied to the game canvas/DOM.",
            "parentId": "undefined",
            "updatedAt": "2026-02-05T08:42:08.531Z"
          },
          {
            "id": 3,
            "title": "Project Documentation and Build Harness Verification",
            "description": "Document the setup process in the README and perform a final smoke test of the integrated harness.",
            "dependencies": [
              2
            ],
            "details": "Create or update 'README.md' with clear instructions on prerequisites, installation, and run/build steps. Verify that the build artifact (Vite build) correctly loads the game, navigates to the splash screen, and handles asset loading via the local harness.",
            "status": "done",
            "testStrategy": "Run 'npm run build' followed by 'npm run preview' and manually verify the game boots to the Main Menu (S1) as per the navigation flow.",
            "parentId": "undefined",
            "updatedAt": "2026-02-05T08:47:52.598Z"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down into: 1) Add bundler/dev server + scripts. 2) Add Phaser boot entrypoint and scene wiring. 3) Document run/build instructions and smoke-test checklist.",
        "updatedAt": "2026-02-05T08:47:52.598Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-02-05T08:47:52.598Z",
      "taskCount": 11,
      "completedCount": 11,
      "tags": [
        "master"
      ],
      "created": "2026-02-05T14:46:54.301Z",
      "description": "Tasks for master context",
      "updated": "2026-02-05T14:46:54.301Z"
    }
  },
  "mvp-full": {
    "tasks": [
      {
        "id": "1",
        "title": "MVP-01 Config Expansion",
        "description": "Expand GameConfig + assets/config/default.yaml to full PRD knobs. Add sections for player stats/blood/actions, NPC behavior/detection, police behavior, heat increase, UI timing, upgrades, maps. Ensure defaults in YAML and no gameplay constants in code.",
        "details": "Test Strategy: schema parse + YAML load + unit tests covering defaults.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [],
        "complexity": 3,
        "recommendedSubtasks": 3,
        "expansionPrompt": "1. Create types/interfaces for the new config sections (Player, NPC, Police, UI, Upgrades).\n2. Update the default YAML file with PRD values.\n3. Implement a schema validation layer (e.g., Zod) to ensure loaded config matches types.",
        "updatedAt": "2026-02-05T17:09:28.580Z"
      },
      {
        "id": "2",
        "title": "MVP-02 DS Tokens v2 + CSS Vars",
        "description": "Align design tokens with PRD (spacing/radius/typography/color roles), add CSS variables for tokens, enforce semantic color roles.",
        "details": "Test Strategy: token enforcement tests pass; no hardcoded layout/color values in UI files.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Design Token Registry (JSON/TS)",
            "description": "Map PRD specifications for colors, spacing, radius, and typography into a structured JSON or TypeScript configuration to serve as the single source of truth.",
            "dependencies": [],
            "details": "Establish a comprehensive registry containing semantic color roles (primary, secondary, feedback), spacing scales, and typography definitions. This registry must export structured objects compatible with the injection utility and component library.",
            "status": "done",
            "testStrategy": "Schema validation and type checks to ensure all required PRD tokens are present and formatted correctly.",
            "updatedAt": "2026-02-05T18:49:06.831Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement CSS Variable Injection Utility",
            "description": "Develop a utility function to transform the design token registry into CSS custom properties and inject them into the application's global stylesheet.",
            "dependencies": [
              1
            ],
            "details": "Iterate through the token registry to generate a valid CSS string for the :root selector. The utility should handle nested objects to create kebab-case variable names (e.g., --ds-color-primary-main) and append the styles to the document head.",
            "status": "done",
            "testStrategy": "Verify the presence of CSS variables in the DOM using browser inspector and unit test the token-to-CSS string conversion logic.",
            "parentId": "undefined",
            "updatedAt": "2026-02-05T18:54:18.389Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 2,
        "expansionPrompt": "1. Define the token registry (JSON/TS) matching the PRD values for colors, spacing, and typography.\n2. Create a utility to inject these tokens as CSS variables into the global stylesheet.",
        "updatedAt": "2026-02-05T18:54:18.389Z"
      },
      {
        "id": "3",
        "title": "MVP-03 DS Components",
        "description": "Implement DS components per PRD: PixelCard, ButtonPrimary/Secondary/Icon, BottomActionBar, HUDChip, ProgressBar, HeatIndicator, Toast, ModalSheet, ListItem, TextField, ToggleSwitch, TooltipHelp.",
        "details": "Test Strategy: component state/render tests (or UI snapshot checks) for required variants.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          "2"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Atomic Buttons and HUDChips",
            "description": "Create the core interactive atomic components: Button (Primary, Secondary, Icon variants) and HUDChip.",
            "dependencies": [],
            "details": "Use Tailwind CSS to implement hover, active, and disabled states. Ensure the Button component supports loading states and icon positioning as seen in the code snippets.",
            "status": "done",
            "testStrategy": "Unit tests for button click handlers and snapshot tests for different variant rendering.",
            "parentId": "undefined",
            "updatedAt": "2026-02-05T18:59:50.309Z"
          },
          {
            "id": 2,
            "title": "Develop Input and Form Control Components",
            "description": "Implement TextField, ToggleSwitch, and TooltipHelp components for user input and guidance.",
            "dependencies": [
              1
            ],
            "details": "Ensure TextField supports focus states and error styling. ToggleSwitch should have smooth transitions and TooltipHelp needs absolute positioning logic.",
            "status": "done",
            "testStrategy": "Interaction testing for toggle state changes and focus/blur behavior for TextFields.",
            "parentId": "undefined",
            "updatedAt": "2026-02-05T19:14:11.296Z"
          },
          {
            "id": 3,
            "title": "Build Feedback and Status Indicators",
            "description": "Implement ProgressBar, HeatIndicator, and Toast components for game state feedback.",
            "dependencies": [
              1
            ],
            "details": "ProgressBar should handle dynamic width updates. HeatIndicator requires specific color gradients for intensity levels. Toast needs a notification queue logic.",
            "status": "done",
            "testStrategy": "Verify ProgressBar width reflects prop percentage and Toast correctly triggers/dismisses.",
            "parentId": "undefined",
            "updatedAt": "2026-02-05T19:17:09.139Z"
          },
          {
            "id": 4,
            "title": "Create Layout and Container Components",
            "description": "Implement the PixelCard and ListItem components to structure data and menus.",
            "dependencies": [
              1
            ],
            "details": "PixelCard should use the specific pixel-art border styling and shadow tokens. ListItem should handle icon slots and click interactions.",
            "status": "done",
            "testStrategy": "UI layout verification to ensure padding and border consistency across different content sizes.",
            "parentId": "undefined",
            "updatedAt": "2026-02-05T19:18:09.593Z"
          },
          {
            "id": 5,
            "title": "Implement Complex Overlay and Action Components",
            "description": "Develop the ModalSheet and BottomActionBar components for high-level UI navigation.",
            "dependencies": [
              1,
              4
            ],
            "details": "ModalSheet must include a backdrop overlay and animation for appearing. BottomActionBar should be fixed to the viewport with z-index management.",
            "status": "done",
            "testStrategy": "Manual verification of modal dismissal behavior and fixed positioning on different screen sizes.",
            "parentId": "undefined",
            "updatedAt": "2026-02-05T19:20:41.554Z"
          },
          {
            "id": 6,
            "title": "Establish Component Gallery and Documentation",
            "description": "Create a gallery page or Storybook setup to visualize all DS components in isolation.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Develop a dedicated route or Storybook config that renders every component variant and state (hover, disabled, etc.) for review.",
            "status": "done",
            "testStrategy": "Visual regression check of all components against design specs in the gallery environment.",
            "parentId": "undefined",
            "updatedAt": "2026-02-05T19:46:22.375Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 6,
        "expansionPrompt": "1. Implement atomic components: Button, Chip, TextField, Toggle.\n2. Implement composite components: PixelCard, ModalSheet, BottomActionBar.\n3. Implement game-specific UI: HealthBar/ProgressBar, HeatIndicator.\n4. Create a Storybook or gallery page to visualize components in isolation.",
        "updatedAt": "2026-02-05T19:46:22.375Z"
      },
      {
        "id": "4",
        "title": "MVP-04 Core Player Systems",
        "description": "Implement PlayerController, FeedingSystem, SunDamageSystem, HeatController; all values config-driven; interruptible feeding; sun grace; heat decay.",
        "details": "Test Strategy: unit tests for bite range, damage per second, heat decay.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement PlayerController State Machine",
            "description": "Develop the PlayerController class to manage player states such as idle, moving, feeding, and dead using config-driven values.",
            "dependencies": [],
            "details": "Create a robust state machine that maps user inputs to player actions while ensuring all movement speeds and state durations are pulled from the GameConfig.",
            "status": "done",
            "testStrategy": "Unit tests for state transitions and input-to-action mapping logic.",
            "parentId": "undefined",
            "updatedAt": "2026-02-05T20:43:13.895Z"
          },
          {
            "id": 2,
            "title": "Develop Interruptible FeedingSystem",
            "description": "Create the FeedingSystem to handle interaction radius detection, bite logic, and interruptible progress bars.",
            "dependencies": [
              1
            ],
            "details": "Implement logic to calculate bite range and manage a feeding timer that resets if the player moves or takes damage, utilizing interaction constants from the YAML config.",
            "status": "done",
            "testStrategy": "Unit tests for bite range verification and interruption triggers upon state changes.",
            "parentId": "undefined",
            "updatedAt": "2026-02-06T09:42:33.694Z"
          },
          {
            "id": 3,
            "title": "Implement SunDamageSystem with Grace Period",
            "description": "Build a system that applies health damage when the player is exposed to sunlight based on environmental checks.",
            "dependencies": [
              1
            ],
            "details": "Implement a damage-per-second (DPS) logic that includes a 'sun grace' period before damage begins. Logic should be decoupled from the physics engine to allow for tile-based or raycast checks.",
            "status": "done",
            "testStrategy": "Unit tests for damage application timing and validation of the grace period duration.",
            "parentId": "undefined",
            "updatedAt": "2026-02-06T11:00:39.751Z"
          },
          {
            "id": 4,
            "title": "Build HeatController and Decay Logic",
            "description": "Implement the HeatController to track global suspicion levels and apply automatic decay over time.",
            "dependencies": [],
            "details": "Develop a controller that tracks 'Heat' as a float value, increasing it based on events and decreasing it using a decay rate defined in the central configuration file.",
            "status": "done",
            "testStrategy": "Unit tests to verify heat accumulation math and decay rates over a simulated timeline.",
            "parentId": "undefined",
            "updatedAt": "2026-02-06T11:01:16.842Z"
          },
          {
            "id": 5,
            "title": "Integrate Core Systems into Testable Harness",
            "description": "Wire the PlayerController, FeedingSystem, SunDamageSystem, and HeatController into a unified framework-agnostic harness.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Construct a main update loop for these systems that operates independently of Phaser's scene lifecycle, allowing for pure logic testing and easier engine integration later.",
            "status": "done",
            "testStrategy": "Integration tests ensuring a single update tick correctly propagates through all four sub-systems.",
            "parentId": "undefined",
            "updatedAt": "2026-02-06T11:02:46.088Z"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 5,
        "expansionPrompt": "1. Implement PlayerController class managing state and input handling.\n2. Create FeedingSystem handling interaction radius and 'bite' logic.\n3. Implement SunDamageSystem with raycasting or tile-check logic.\n4. Build HeatController to track suspicion levels and decay over time.\n5. Wire these systems into a testable harness independent of Phaser scenes.",
        "updatedAt": "2026-02-06T11:02:46.088Z"
      },
      {
        "id": "5",
        "title": "MVP-05 Detection + NPC AI",
        "description": "Implement DetectionController (LOS + distance), NPC state machine (Calm/Suspicious/Alarmed/Panic), and base wandering behavior.",
        "details": "Test Strategy: detection transitions and LOS blocking tests.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          "4"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Line-of-Sight (LOS) Utility",
            "description": "Develop a utility class to calculate visibility between two points using the game's tilemap data.",
            "dependencies": [],
            "details": "Use a raycasting algorithm or Bresenham's line algorithm to check for collision tiles between the NPC and the player coordinates.",
            "status": "done",
            "testStrategy": "Run unit tests with a mock tilemap to ensure walls correctly block visibility while empty space allows it.",
            "parentId": "undefined",
            "updatedAt": "2026-02-06T11:40:16.157Z"
          },
          {
            "id": 2,
            "title": "Create NPC Finite State Machine (FSM) Base",
            "description": "Design and implement the abstract base classes for the NPC state machine and individual states.",
            "dependencies": [],
            "details": "Implement a StateMachine class with methods for ChangeState, Update, and handle entry/exit logic for different NPC behaviors.",
            "status": "done",
            "testStrategy": "Verify that state transitions occur correctly and that Enter/Exit hooks are called in the expected sequence.",
            "parentId": "undefined",
            "updatedAt": "2026-02-06T11:41:50.899Z"
          },
          {
            "id": 3,
            "title": "Implement Specific NPC States",
            "description": "Develop logic for Idle/Wander, Suspicious (investigate), and Alarmed (flee or alert) states.",
            "dependencies": [
              2
            ],
            "details": "Wander should use random point generation; Suspicious moves toward a noise or last-seen point; Alarmed increases movement speed and alerts neighbors.",
            "status": "done",
            "testStrategy": "Manual simulation of state transitions triggered by external variables like detection level or proximity.",
            "parentId": "undefined",
            "updatedAt": "2026-02-06T11:43:28.656Z"
          },
          {
            "id": 4,
            "title": "Create DetectionController Component",
            "description": "Build a component that manages NPC awareness using vision cones, distance, and the LOS utility.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "The controller will calculate awareness gain based on the player's proximity and angle relative to the NPC's forward vector and LOS clear path.",
            "status": "done",
            "testStrategy": "Integration tests to verify awareness bar increases only when the player is inside the detection cone and LOS is not blocked.",
            "parentId": "undefined",
            "updatedAt": "2026-02-06T11:51:48.633Z"
          },
          {
            "id": 5,
            "title": "Optimize Neighbor Lookup for AI Communication",
            "description": "Implement a spatial partitioning or grid-based system to efficiently find nearby NPCs for behavior propagation.",
            "dependencies": [
              4
            ],
            "details": "Avoid O(N^2) checks by using a spatial hash or simple grid to let Alarmed NPCs quickly notify nearby units to change their state.",
            "status": "done",
            "testStrategy": "Measure performance with high NPC counts and verify that 'Alarm' state spreads correctly within a specific radius.",
            "parentId": "undefined",
            "updatedAt": "2026-02-06T11:54:06.293Z"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 5,
        "expansionPrompt": "1. Implement Line-of-Sight (LOS) utility handling tilemap collisions.\n2. Create the NPC State Machine (FSM) base class.\n3. Implement specific states: Idle/Wander, Suspicious (investigate), Alarmed (flee/alert).\n4. Create DetectionController to manage awareness cones/circles for NPCs.\n5. Optimize neighbor lookups for NPC-to-NPC communication.",
        "updatedAt": "2026-02-06T11:54:06.293Z"
      },
      {
        "id": "6",
        "title": "MVP-06 Panic + Police",
        "description": "Integrate panic bubble with NPC state changes; police response localized to bubble; night multiplier applied.",
        "details": "Test Strategy: bubble radius affects NPCs only inside; police spawn count respects night multiplier.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          "5"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Panic Bubble Propagation Logic",
            "description": "Develop the mechanism where a panic event alerts nearby NPCs within a configurable radius.",
            "dependencies": [],
            "details": "Use spatial partitioning or distance checks to transition NPC states from 'Idle' to 'Flee' when within the bubble radius.",
            "status": "done",
            "testStrategy": "Verify that only NPCs within the designated radius transition to panic states and that the radius matches config values.",
            "parentId": "undefined",
            "updatedAt": "2026-02-06T12:59:37.282Z"
          },
          {
            "id": 2,
            "title": "Create PoliceSpawner and Heat-Based Logic",
            "description": "Build a spawning system that generates police units based on the current global Heat level and applies night multipliers.",
            "dependencies": [
              1
            ],
            "details": "Calculate spawn count using Heat level and Night Multiplier from game config; ensure police spawn near active panic zones.",
            "status": "done",
            "testStrategy": "Validate that the police spawn count correctly scales with the night multiplier and global heat level thresholds.",
            "parentId": "undefined",
            "updatedAt": "2026-02-06T13:00:03.040Z"
          },
          {
            "id": 3,
            "title": "Implement Police AI Chase Behavior",
            "description": "Design the Police AI to track and move toward the player character, distinct from civilian flight patterns.",
            "dependencies": [
              2
            ],
            "details": "Implement pathfinding or steering behaviors that specifically target the player's coordinates when the police unit is in 'Pursuit' mode.",
            "status": "done",
            "testStrategy": "Observe and confirm that police NPCs move toward the player while civilian NPCs move in the opposite direction.",
            "parentId": "undefined",
            "updatedAt": "2026-02-06T13:00:31.568Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "1. Implement 'Panic Bubble' propagation logic (NPCs alerting nearby NPCs).\n2. Create PoliceSpawner logic based on global Heat level.\n3. Implement basic Police AI (chase player) distinct from Civilian AI (flee).",
        "updatedAt": "2026-02-06T13:00:31.568Z"
      },
      {
        "id": "7",
        "title": "MVP-07 Maps + Placeholder Assets",
        "description": "Add placeholder tilemaps and sprites; 3 districts and 610 interiors; map list stored in config.",
        "details": "Test Strategy: assets load without errors.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "1. Create Tiled tilemaps for Town, Interior, and Castle using placeholder tilesets.\n2. Define collision layers and spawn points in map data.\n3. Create an AssetLoader service to manage map parsing and sprite loading.",
        "updatedAt": "2026-02-06T14:10:25.249Z"
      },
      {
        "id": "8",
        "title": "MVP-08 Phaser Scene Wrappers",
        "description": "Build Phaser scenes for Town/Interior/Castle wired to controllers, input, tilemaps, and transitions. Keep logic outside scenes.",
        "details": "Test Strategy: scene boot + transitions + respawn.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          "4",
          "7"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Create BaseScene Abstract Class",
            "description": "Establish a foundation class that extends Phaser.Scene to centralize common functionality like input mapping and screen resizing.",
            "dependencies": [],
            "details": "Implement boilerplate for handling standard input events and camera resizing to ensure consistent behavior across all game environments.",
            "status": "done",
            "testStrategy": "Verify that input listeners are correctly initialized and window resize events trigger appropriate camera adjustments.",
            "parentId": "undefined",
            "updatedAt": "2026-02-06T16:23:37.971Z"
          },
          {
            "id": 2,
            "title": "Implement Location-Specific Scenes",
            "description": "Develop concrete subclasses for TownScene, InteriorScene, and CastleScene that utilize the BaseScene foundation.",
            "dependencies": [
              1
            ],
            "details": "Initialize tilemaps, tilesets, and layer depths for the Town, Interior, and Castle maps using external JSON configuration data.",
            "status": "done",
            "testStrategy": "Perform visual verification of scene loading and ensure correct layer sorting for each specific environment.",
            "parentId": "undefined",
            "updatedAt": "2026-02-06T16:23:46.103Z"
          },
          {
            "id": 3,
            "title": "Develop SceneTransitionManager",
            "description": "Create a centralized manager to handle smooth camera transitions and data persistence between different game locations.",
            "dependencies": [
              2
            ],
            "details": "Implement camera fade-in/out effects and a data passing mechanism to transfer player state (HP, Blood, Heat) between scene changes.",
            "status": "done",
            "testStrategy": "Execute scene swap commands and assert that transition data reaches the destination scene correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-02-06T16:23:54.388Z"
          },
          {
            "id": 4,
            "title": "Integrate Logic Controllers into Update Loops",
            "description": "Bridge the decoupled logic controllers (Player, Heat, NPC) into the Phaser scene lifecycle for real-time execution.",
            "dependencies": [
              1,
              2
            ],
            "details": "Wire the Scene's update(time, delta) method to trigger the update cycles of the core systems while maintaining clear decoupling.",
            "status": "done",
            "testStrategy": "Monitor controller state changes within the scene loop to ensure physics and logic updates occur every frame.",
            "parentId": "undefined",
            "updatedAt": "2026-02-06T16:24:03.746Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "1. Create BaseScene class to handle common setup (input, resizing).\n2. Implement TownScene, InteriorScene, CastleScene.\n3. Build a SceneTransitionManager to handle fading and data passing between scenes.\n4. Connect the Logic Controllers (Task 4/5) to the Scene update loops.",
        "updatedAt": "2026-02-06T16:24:03.746Z"
      },
      {
        "id": "9",
        "title": "MVP-09 HUD + Overlays",
        "description": "Implement HUD and overlays (TargetRingFlash/Outline, PanicAreaIndicator, SunDangerOverlay, TapMarker, damage/panic flash) using DS tokens; config-driven timings.",
        "details": "Test Strategy: overlay triggers and timings.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          "3",
          "4"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Establish React-Phaser Overlay Infrastructure",
            "description": "Create the React-based DOM layer positioned over the Phaser canvas and implement the state bridge for game data synchronization.",
            "dependencies": [],
            "details": "Implement a high-performance event bus or store bridge to pass data from the Phaser update loop to React without triggering full app re-renders. Set up the CSS layout to ensure the HUD remains interactive while the game canvas renders underneath.",
            "status": "done",
            "testStrategy": "Verify React overlay visibility over the canvas and measure latency of state updates from Phaser to the UI layer.",
            "parentId": "undefined",
            "updatedAt": "2026-02-06T16:31:31.457Z"
          },
          {
            "id": 2,
            "title": "Bind HUD Components to Player State Stores",
            "description": "Integrate DS components like ProgressBar and HUDChip to display real-time Health and Heat levels based on GameConfig values.",
            "dependencies": [
              1
            ],
            "details": "Connect the HUD components to the SunDamageSystem and HeatController data. Use Design System tokens for styling and ensure that bar transitions and chip updates use the config-driven UI timings defined in Task 1.",
            "status": "done",
            "testStrategy": "Unit test state-to-component mapping and manually verify that health/heat bars reflect in-game changes immediately.",
            "parentId": "undefined",
            "updatedAt": "2026-02-06T16:32:04.541Z"
          },
          {
            "id": 3,
            "title": "Implement Visual Overlays for Environmental States",
            "description": "Build the full-screen visual indicators for Sun Damage (red vignette), Panic (flashing borders), and UI markers.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create the SunDangerOverlay and PanicAreaIndicator using CSS animations and SVG filters. Implement the TargetRingFlash and TapMarker with configuration-driven durations and easing functions as specified in the game config.",
            "status": "done",
            "testStrategy": "Trigger specific game states (sun exposure, high heat) and verify that the corresponding overlays activate and deactivate with correct timings.",
            "parentId": "undefined",
            "updatedAt": "2026-02-06T16:32:39.301Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "1. Create the React/HTML overlay layer sitting on top of the Phaser canvas.\n2. Bind HUD components (Health, Heat) to Game State stores.\n3. Implement visual overlays for specific states: Sun Damage (red vignette), Panic (flashing borders).",
        "updatedAt": "2026-02-06T16:32:39.301Z"
      },
      {
        "id": "10",
        "title": "MVP-10 Screens S0S10 + Navigation",
        "description": "Implement full UI flow (Splash, Main, Character Select, Castle, Upgrades, Settings, Pause, Death, Credits) using DS components and NavigationController.",
        "details": "Test Strategy: end-to-end navigation flow.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          "3"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Setup NavigationController and Routing Logic",
            "description": "Create a central hub to manage screen transitions, history stack, and deep linking for all MVP screens.",
            "dependencies": [],
            "details": "Implement a stack-based router that supports pushing and popping screens while handling platform-specific back button events and lifecycle hooks.",
            "status": "done",
            "testStrategy": "Verify navigation stack integrity and history management through unit tests and route tracking.",
            "parentId": "undefined",
            "updatedAt": "2026-02-06T14:20:53.558Z"
          },
          {
            "id": 2,
            "title": "Implement Static UI Screens (Splash, Main, Credits, Settings)",
            "description": "Develop the low-complexity informational screens using existing Design System components.",
            "dependencies": [
              1
            ],
            "details": "Construct the Splash, MainMenu, Credits, and Settings screens ensuring they utilize PixelCard and Button components from the Design System.",
            "status": "done",
            "testStrategy": "UI smoke tests to ensure layout consistency across different screen sizes and button click navigation.",
            "parentId": "undefined",
            "updatedAt": "2026-02-06T14:20:59.668Z"
          },
          {
            "id": 3,
            "title": "Implement Interactive Data-Driven Screens (CharacterSelect, Upgrades)",
            "description": "Build screens requiring complex data binding from GameConfig and persistent state mutation for player progression.",
            "dependencies": [
              1,
              2
            ],
            "details": "Integrate CharacterSelect with player stat visualization and the Upgrades screen with stateful logic that updates based on player currency/blood.",
            "status": "done",
            "testStrategy": "Integration tests to verify that selections in CharacterSelect and purchases in Upgrades persist across navigation sessions.",
            "parentId": "undefined",
            "updatedAt": "2026-02-06T14:21:05.605Z"
          },
          {
            "id": 4,
            "title": "End-to-End Navigation Flow and Transition Refinement",
            "description": "Finalize screen transitions for Pause, Death, and Castle screens to ensure a cohesive user experience.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Add animated transitions between states, implement the Pause overlay logic, and hook the Death screen into the core gameplay event system.",
            "status": "done",
            "testStrategy": "Full end-to-end manual walkthrough of the S0 through S10 screen flow to identify any broken links or transition glitches.",
            "parentId": "undefined",
            "updatedAt": "2026-02-06T14:21:13.492Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "1. Set up a global Router or Screen Manager.\n2. Implement static screens: Splash, MainMenu, Credits, Settings.\n3. Implement complex screens: CharacterSelect (data binding), Upgrades (state mutation).\n4. Ensure cohesive navigation flow (back button handling, transitions).",
        "updatedAt": "2026-02-06T14:21:13.492Z"
      },
      {
        "id": "11",
        "title": "MVP-11 Save + Upgrades",
        "description": "Implement local save for player name, settings, upgrades; upgrades defined in config and exposed in UI.",
        "details": "Test Strategy: persistence round-trip tests.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          "10"
        ],
        "priority": "medium",
        "subtasks": [],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "1. Define the SaveData schema (JSON serializable).\n2. Implement LocalStorage adapter with save/load/delete methods.\n3. Create the UpgradeManager to apply unlocked modifiers to GameConfig at runtime.",
        "updatedAt": "2026-02-06T16:45:09.862Z"
      },
      {
        "id": "12",
        "title": "MVP-12 PWA Minimal",
        "description": "Add manifest.json, icons, and meta tags for installability. No service worker/offline cache.",
        "details": "Test Strategy: installability in Chrome/Safari (manual).",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [],
        "complexity": 2,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Generate manifest and meta tags. Verify icon sizes.",
        "updatedAt": "2026-02-06T16:51:14.291Z"
      },
      {
        "id": "13",
        "title": "MVP-13 QA + Acceptance",
        "description": "Expand tests + manual checklist for full MVP acceptance criteria.",
        "details": "Test Strategy: full regression pass.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          "8",
          "9",
          "10",
          "11"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Write integration tests for critical user flows (Start Game -> Play -> Die -> Restart)",
            "description": "Develop and implement automated integration tests covering the end-to-end gameplay loop and state transitions.",
            "dependencies": [],
            "details": "Focus on logic-layer state transitions and game engine lifecycle events to ensure stability of the core flow across screens without relying purely on UI rendering.",
            "status": "done",
            "testStrategy": "Automated execution of Vitest/Jest integration suites simulating state changes from initialization to death and restart.",
            "parentId": "undefined",
            "updatedAt": "2026-02-06T16:59:23.456Z"
          },
          {
            "id": 2,
            "title": "Perform manual acceptance testing against the PRD checklist",
            "description": "Execute a comprehensive manual QA pass following the Product Requirements Document to ensure all features meet defined criteria.",
            "dependencies": [
              1
            ],
            "details": "Verify UI responsiveness, PWA installability, local save persistence, and edge-case behaviors across targeted mobile and desktop browsers.",
            "status": "done",
            "testStrategy": "Cross-browser manual testing using Chrome and Safari; verification against the master PRD acceptance spreadsheet.",
            "parentId": "undefined",
            "updatedAt": "2026-02-06T16:59:29.753Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 2,
        "expansionPrompt": "1. Write integration tests for critical user flows (Start Game -> Play -> Die -> Restart).\n2. Perform manual acceptance testing against the PRD checklist.",
        "updatedAt": "2026-02-06T16:59:29.753Z"
      },
      {
        "id": "14",
        "title": "MVP-AFTER Doc",
        "description": "Create AFTER_MVP.md with deferred items (PWA offline + cloud sync).",
        "details": "Test Strategy: file exists, content verified.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "low",
        "subtasks": [],
        "complexity": 1,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Compile known tech debt and future features into markdown.",
        "updatedAt": "2026-02-06T17:47:13.546Z"
      },
      {
        "id": "15",
        "title": "MVP-14 Playable Loop: Phaser Town Scene & Interaction",
        "description": "Integrate the core Phaser gameplay loop by implementing the Town scene with tap-to-move mechanics and a minimal HUD overlay.",
        "details": "This task bridges the UI systems and the Phaser engine to create a functional game loop. \n\n1. **Phaser Scene Implementation**: Create `TownScene` in `src/game/scenes/`. Use `GameConfig` (Task 1) to load map dimensions and tile assets. \n2. **Navigation Integration**: Update the `NavigationController` (Task 10) to initiate the Phaser instance and switch to the `TownScene` when the user enters the game from the Castle or Character Select screens.\n3. **Tap-to-Move Mechanics**: Extend the `PlayerController` (Task 4) to support target-based movement. Register a pointer-down listener in Phaser that calculates the path/direction toward the clicked coordinate and moves the player sprite until the destination is reached.\n4. **HUD Overlay**: Implement a minimal HUD using DS components (Task 3) like `HUDChip` and `ProgressBar`. This HUD should be a React layer rendered over the Phaser canvas, subscribing to state updates from `PlayerController` (Blood levels) and `HeatController` (Heat/Police status).\n5. **Camera System**: Configure the Phaser camera to follow the player with appropriate lerp/deadzone settings defined in the config.\n6. **Auto-Start**: For development/MVP testing, ensure the game can optionally skip the splash screen and boot directly into the Town scene via a config flag.",
        "testStrategy": "1. Functional Test: Click/tap on various points in the Town scene and verify the player sprite moves to the correct location.\n2. Integration Test: Navigate from the Main Menu to the Town scene and confirm the Phaser engine initializes without errors.\n3. UI Test: Manually trigger Blood loss and Heat gain via dev console and verify the HUD components (HUDChip/ProgressBar) reflect the changes immediately.\n4. Performance Test: Ensure the overlay HUD does not cause frame drops during player movement.",
        "status": "done",
        "dependencies": [
          "1",
          "3",
          "4",
          "10"
        ],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-02-09T06:42:57.431Z"
      },
      {
        "id": "16",
        "title": "MVP-14 Playable Loop Integration",
        "description": "Auto-start Town scene, enable tap-to-move, and add minimal HUD so the game is immediately playable.",
        "details": "Implementation: start Town from Boot immediately; wire pointer input in PhaserTownScene to move player toward target using config-based speed; render minimal HUD text with phase/time, HP/Blood, Heat. Add small time-format helper + unit test. Run npm test.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-02-06T17:20:44.007Z"
      },
      {
        "id": "17",
        "title": "MVP-15 Placeholder Visuals",
        "description": "Replace transparent placeholder assets with visible 16x16 PNGs and align map tileset metadata so Town renders visibly.",
        "details": "Generate solid-color 16x16 PNGs for tileset/player/npc; update tileset imagewidth/imageheight in map JSONs to 16; verify Town renders; run npm test.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-02-06T17:29:51.193Z"
      },
      {
        "id": "18",
        "title": "Static Assets Relocation + Config Import",
        "description": "Move assets into public for Vite serving and import config YAML via ?raw; update loader and tests.",
        "details": "Move assets/* (maps/sprites/tilesets/icons) to public/assets. Move assets/config/default.yaml to src/config/default.yaml. Add parseConfigYaml helper, use in loadConfig and main bootstrap via ?raw import. Add vite-env.d.ts for raw import typing. Update config-loader test path. Run npm test.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [],
        "updatedAt": "2026-02-06T17:43:33.542Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-02-09T06:42:57.431Z",
      "taskCount": 18,
      "completedCount": 18,
      "tags": [
        "mvp-full"
      ]
    }
  },
  "full-game-alpha": {
    "tasks": [
      {
        "id": 1,
        "title": "FGA-01 Town Tilemap Districts and Tileset Integration",
        "description": "Design and integrate three functional town districts (Residential, Main, and Industrial) using Tiled, incorporating multi-layered tile structures and gameplay-essential object spawns.",
        "details": "This task involves creating three distinct map files (residential.tmx/json, main.tmx/json, and industrial.tmx/json) that follow a standardized architectural pattern for the game engine. \n\n1. **Layer Hierarchy**: Each map must contain exactly these tile layers in the following order: 'Ground' (z:0), 'Roads' (z:1), 'Parks' (z:2), 'Buildings' (z:3), 'Trees' (z:4), 'Obstacles' (z:5), and 'Shadow' (z:6). \n2. **Collision Logic**: Define collision shapes within the 'Obstacles' and 'Buildings' layers. Ensure that the tileset used is correctly linked and named to match the project's internal asset manifest (e.g., 'town_tileset').\n3. **Object Layer 'Spawns'**: Create an object layer containing specific markers:\n    - 'player_spawn': The initial coordinate for the player.\n    - 'npc_spawn': Generic locations for ambient AI.\n    - 'police_spawn': Locations specifically for security units.\n    - 'interior_exit': Triggers for map transitions.\n4. **Asset Alignment**: Verify that the tileset embedding uses relative paths and that the JSON exports are saved to the 'assets/maps/' directory.\n\nDefinition of Done:\n- Three Tiled district maps exist: public/assets/maps/town-district-1.json, town-district-2.json, town-district-3.json.\n- Each map contains layers Ground, Roads, Buildings, Parks, Trees, Obstacles, Shadow (case-sensitive).\n- Each map contains object layer Spawns with objects named player_spawn, npc_spawn, police_spawn, interior_exit.\n- Tileset name in map JSON matches config tileset key; addTilesetImage succeeds.\n- Phaser Town renders layers (no black screen) and collision layer is active.",
        "testStrategy": "1. Render Verification: Load each of the three districts in the game engine and verify that all 7 layers are visible and correctly ordered (e.g., shadows appearing over the ground).\n2. Collision Check: Navigate the player character across the map; confirm that movement is physically blocked by tiles on the 'Obstacles' and 'Buildings' layers.\n3. Spawn Point Validation: Verify that the player successfully initializes at the 'player_spawn' coordinates and that NPC entities are correctly instantiated at 'npc_spawn' markers.\n4. Boundary Testing: Walk to an 'interior_exit' object to ensure the trigger detection system recognizes the object boundaries.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Generate residential district JSON map",
            "description": "Create town-district-1.json with required layers and Spawns object layer via script (not Tiled).",
            "dependencies": [],
            "details": "Initialize layers: Ground (z:0), Roads (z:1), Parks (z:2), Buildings (z:3), Trees (z:4), Obstacles (z:5), and Shadow (z:6). Link the 'town_tileset' using relative asset paths.",
            "status": "done",
            "testStrategy": "Open the TMX file in Tiled and verify that all 7 layers exist in the specific order and the tileset renders without missing image errors.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Generate main + industrial district JSON maps",
            "description": "Create town-district-2.json and town-district-3.json with required layers and Spawns object layer via script (not Tiled).",
            "dependencies": [
              1
            ],
            "details": "Draft main.tmx and industrial.tmx. Ensure architectural consistency across districts while maintaining the identical 7-layer structure and layer naming conventions.",
            "status": "done",
            "testStrategy": "Visual inspection in Tiled to ensure the Main and Industrial districts follow the same layer hierarchy as the Residential district.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Add spawn objects and collision layer config",
            "description": "Ensure player/npc/police/exit objects exist and Town scene configures collision for Obstacles.",
            "dependencies": [
              1,
              2
            ],
            "details": "In the 'Spawns' object layer for each map, place 'player_spawn', 'npc_spawn', 'police_spawn', and 'interior_exit' markers with correct naming for engine compatibility.",
            "status": "done",
            "testStrategy": "Verify in Tiled's 'Object' panel that all spawns are named correctly and collision shapes are visible on relevant tiles in the tile collision editor.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Wire Town scene to render full layer stack",
            "description": "Town scene renders Ground/Roads/Parks/Buildings/Trees/Obstacles/Shadow and uses Arcade physics.",
            "dependencies": [
              3
            ],
            "details": "Save JSON exports to 'public/assets/maps/'. Update the game's preloader to use this.load.tilemapTiledJSON and check that addTilesetImage correctly maps the 'town_tileset' key.",
            "status": "done",
            "testStrategy": "Run the Phaser application; confirm through the console that maps load successfully and use a debug render to verify that all 7 layers and collisions are active.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Provide subtasks for designing the Residential, Main, and Industrial TMX files, defining collision shapes in Tiled, and implementing the Phaser loader to verify the 7-layer hierarchy.",
        "updatedAt": "2026-02-07T08:03:41.249Z"
      },
      {
        "id": 2,
        "title": "Placeholder Asset Pack and Configuration Wiring",
        "description": "Create 16x16 pixel art placeholder assets for tilesets and character sprites, and integrate them into the game's asset loading configuration.",
        "details": "1. Asset Creation: Generate a 16x16 pixel tileset (placeholder_tiles.png) covering ground, roads, and building basics to match the layers defined in the town districts. 2. Sprite Sheets: Create character sprite sheets for 'Player', 'Police', and 'Humans' (with variants for child, adult, and old). Each frame must be exactly 16x16 pixels. 3. Config Schema: Update the global asset configuration (e.g., src/config/assets.ts) to define sprite keys, frame dimensions, and basic animation sequences (idle, walk). 4. Asset Loader: Update the Phaser Preloader scene to load these PNGs and associate them with the keys used in the Tilemap integration. 5. Alignment: Ensure that the 16x16 grid matches the Figma design specs and the Tiled map grid size to prevent bleed-through or misalignment during rendering.\n\nDefinition of Done:\n- Placeholder assets created: tileset and sprite sheets (player, humans, police) in public/assets/tilesets and public/assets/sprites.\n- Config schema + default YAML updated with new asset entries and dimensions.\n- Phaser loads assets with correct frame sizes and renders sprites on scene.",
        "testStrategy": "1. Asset Load Verification: Confirm through the browser network tab and Phaser debug logs that all textures load without errors. 2. Visual Audit: Render each character type in a test scene to verify correct frame slicing (no partial sprites). 3. Tile Alignment: Load a district map from Task 1 and verify that tiles align perfectly to the 16x16 grid without gaps. 4. Config Validation: Verify that the asset configuration correctly identifies the 'Human' variants (child/adult/old) by rendering different colors/shapes for each placeholder.",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "high",
        "subtasks": [],
        "complexity": 3,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Create subtasks for generating 16x16 PNGs for tiles and sprites, updating the global asset configuration file, and extending the Phaser Preloader to map these assets to game keys.",
        "updatedAt": "2026-02-07T08:27:53.413Z"
      },
      {
        "id": 3,
        "title": "World Grid System and Spatial Masks",
        "description": "Develop a grid-based module to manage walkability, line-of-sight blocking, and sun-safety data derived from Tiled map layers and coordinate conversion helpers.",
        "details": "1. **Grid Data Structure**: Create a `WorldGrid` class in `src/core/grid.ts` that processes the Tiled JSON data from Task 1. Use TypedArrays (e.g., `Uint8Array`) to store bitmasks for each tile coordinate: bit 0 for WALKABLE, bit 1 for LOS_BLOCK, and bit 2 for SUN_SAFE.\n2. **Mask Derivation Logic**: \n   - **WALKABLE**: True if tile is in 'Ground' or 'Roads' and NOT in 'Buildings' or 'Obstacles'.\n   - **LOS_BLOCK**: True if tile contains data in 'Buildings' or 'Trees' layers.\n   - **SUN_SAFE**: True if tile contains data in the 'Shadow' layer.\n3. **Coordinate Helpers**: Implement `worldToTile(x, y)` and `tileToWorld(tx, ty)` methods, enforcing the 16x16 pixel alignment defined in Task 2. Ensure these handle floating point inputs by flooring values.\n4. **System Integration**: \n   - **Pathfinding**: Provide a grid getter that returns a 2D array representation for EasyStar.js or a custom A* implementation.\n   - **Sun/Shade**: Create a `isSunSafe(worldX, worldY)` helper for the character state machine to trigger 'burning' status.\n   - **Collisions**: Use the grid data to populate a static collision layer in the Phaser Town scene for physical blocking.\n\nDefinition of Done:\n- world-grid module outputs walkable/losBlocked/sunSafe masks from Tiled layers/properties.\n- worldToTile/tileToWorld helpers added and used by pathfinding/LOS/sun systems.\n- Phaser Town uses masks for collisions/pathfinding.\n- Tests validate mask correctness and pathfinding works.",
        "testStrategy": "1. Coordinate Accuracy: Run unit tests to verify that world coordinates (e.g., 35, 40) correctly map to tile (2, 2) in a 16px grid.\n2. Mask Verification: Create a debug overlay in the Phaser scene that tints walkable tiles green, LOS-blocked tiles red, and sun-safe tiles blue to visually confirm they match the Tiled source.\n3. Pathfinding Stress Test: Command an NPC to move across a complex building layout; verify that the path strictly adheres to the 'WALKABLE' mask and avoids 'Obstacles'.",
        "status": "done",
        "dependencies": [
          "1",
          "2"
        ],
        "priority": "medium",
        "subtasks": [],
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Define subtasks for the WorldGrid class development, the bitmask derivation logic from Tiled data, coordinate conversion helpers, and the debug overlay for mask visualization.",
        "updatedAt": "2026-02-07T08:33:39.993Z"
      },
      {
        "id": 4,
        "title": "Phaser HUD, Overlays, and Playable Gameplay Loop Integration",
        "description": "Implement a Phaser-based HUD and visual overlays while wiring the core gameplay loop from movement and targeting to feeding and police evasion.",
        "details": "1. **HUD Implementation**: Create a `UIScene` to render persistent status bars for HP, Blood (energy), and Heat (suspicion), along with a clock displaying the day/night cycle. 2. **Visual Overlays**: Integrate a 'Target Ring' using Phaser Graphics that follows the currently selected NPC. Implement a 'Sun Danger' overlay that uses the `SUN_SAFE` bitmask from the `WorldGrid` (Task 3) to tint dangerous tiles red during daylight. 3. **Input & Interaction**: Map pointer clicks to `tap-to-move` logic and `tap-to-target`. Implement buttons for 'Bite' (starts feeding sequence), 'Escape' (breaks contact), and 'Hide'. 4. **Gameplay Loop Controller**: Develop a state machine to manage transitions: Idle -> Moving -> Targeting -> Feeding -> Panic (if spotted) -> Police Chase -> Death/Respawn. Use the grid logic to determine if the player is in LOS of NPCs or Police during the loop.\n\nDefinition of Done:\n- Phaser-only HUD shows time, HP, blood, heat; action buttons visible.\n- Overlays render: target ring/outline, panic area, sun danger.\n- Inputs wired: tap-to-move, tap-to-target, bite/escape/hide.\n- End-to-end loop is playable in Town and npm test passes.",
        "testStrategy": "1. UI Verification: Manually verify that HP, Blood, and Heat bars decrement/increment correctly in response to game events. 2. Integration Test: Execute a complete 'Bite' looptarget an NPC, initiate feeding, trigger a 'Panic' event, and verify police sprites spawn and path toward the player. 3. Overlay Alignment: Confirm the 'Sun Danger' overlay accurately highlights tiles marked as non-SUN_SAFE in the WorldGrid. 4. Regression: Run 'npm test' to ensure existing grid and map loading functionalities remain intact.",
        "status": "done",
        "dependencies": [
          "1",
          "2",
          "3"
        ],
        "priority": "high",
        "subtasks": [],
        "complexity": 8,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Break this down into the UI Scene implementation, status bar logic, visual targeting/danger overlays, input handler mapping, and the core gameplay state machine.",
        "updatedAt": "2026-02-07T08:36:06.938Z"
      },
      {
        "id": 5,
        "title": "NPC Entity System and Human Behavior Implementation",
        "description": "Implement the HumanNpc entity class and a management system to handle sprite pooling, randomized behaviors, and attribute variants based on district density.",
        "details": "1. **Entity Architecture**: Create a HumanNpc class in `src/entities/npc.ts` that extends Phaser.GameObjects.Sprite. Integrate a simple state machine to manage IDLE and WANDER states. 2. **Configurable Variants**: Define an NPC_TYPE_CONFIG object with multipliers for 'child', 'adult', and 'old'. Properties should include `moveSpeed` (e.g., child: 1.2, old: 0.7) and `bloodQuality` (e.g., child: 0.5, old: 1.5). 3. **NPC Manager & Pooling**: Develop an NpcManager to handle spawning. Use a `Phaser.GameObjects.Group` with `classType: HumanNpc` and `runChildUpdate: true` for efficient sprite pooling. 4. **Spawning Logic**: Parse 'npc_spawn' object points from the Tiled maps (Task 1). Implement a spawn clock that respects `performance.maxActiveNpcs` and adjusts frequency based on the current district's density settings. 5. **AI Movement**: In the WANDER state, use the `WorldGrid` from Task 3 to pick a random neighbor tile that is marked as `WALKABLE`. Implement a simple lerp or velocity-based movement to the target tile.\n\nDefinition of Done:\n- Human NPC entities spawn from npc_spawn points and are pooled.\n- NPCs wander on walkable tiles and pause; behavior is visible.\n- Child/adult/old variants differ by speed and blood quality via config.\n- maxActiveNpcs limit respected.",
        "testStrategy": "1. **Behavioral Audit**: Observe NPCs in the game; verify they move to a random nearby tile, wait for a random duration (1-3s), and then move again. 2. **Constraint Testing**: Set `maxActiveNpcs` to a low number (e.g., 10) and verify that the NpcManager stops spawning once the limit is reached. 3. **Spatial Validation**: Use the debug overlay from Task 3 to ensure NPCs never step on tiles marked as non-walkable (Buildings/Obstacles). 4. **Variant Verification**: Confirm via console logs that spawned NPCs are assigned a random type (child/adult/old) and that their movement speed matches the configured multiplier.",
        "status": "done",
        "dependencies": [
          "1",
          "2",
          "3"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Define NPC Configuration and Variant Constants",
            "description": "Create a centralized configuration file to store attribute multipliers for different NPC types like child, adult, and old.",
            "dependencies": [],
            "details": "Define NPC_TYPE_CONFIG in src/config/npc.ts with moveSpeed (child: 1.2, adult: 1.0, old: 0.7) and bloodQuality (child: 0.5, adult: 1.0, old: 1.5) multipliers.",
            "status": "pending",
            "testStrategy": "Unit test to verify that the config object is immutable and returns the correct multipliers for each age string key.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement HumanNpc Sprite Class with State Machine",
            "description": "Develop the core HumanNpc class extending Phaser's Sprite and integrate a simple state machine to manage behavioral logic.",
            "dependencies": [
              1
            ],
            "details": "Implement src/entities/npc.ts. The class should store its current state (IDLE or WANDER) and apply the configuration multipliers defined in Subtask 1 to its base attributes.",
            "status": "pending",
            "testStrategy": "Verify the NPC class correctly inherits from Phaser.GameObjects.Sprite and logs a console message when transitioning from IDLE to WANDER.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Develop NpcManager with Sprite Pooling",
            "description": "Create a management system to handle the lifecycle of NPCs, including efficient sprite pooling and spawning based on map data.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create NpcManager in src/core/npcManager.ts using a Phaser.GameObjects.Group. Implement logic to parse 'npc_spawn' points from the Tiled JSON and manage the maxActiveNpcs limit.",
            "status": "pending",
            "testStrategy": "Visual confirmation that NPCs spawn at specific map markers and that the group size does not exceed the maxActiveNpcs variable.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Random Wander AI and Grid Movement",
            "description": "Connect the NPC state machine to the WorldGrid system to enable random movement on walkable tiles.",
            "dependencies": [
              2,
              3
            ],
            "details": "In the WANDER state, query the WorldGrid for a random neighboring tile with the WALKABLE bit set. Use Phaser velocity or a lerp to move the NPC to the center of the target tile.",
            "status": "pending",
            "testStrategy": "Behavioral audit to ensure NPCs never move into non-walkable tiles (Buildings/Obstacles) and successfully navigate to adjacent walkable tiles.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Outline subtasks for the HumanNpc class, the variant configuration system, the NpcManager with object pooling, and the random-wander AI state logic.",
        "updatedAt": "2026-02-07T08:38:10.067Z"
      },
      {
        "id": 6,
        "title": "Police Response and Panic Propagation Loop",
        "description": "Implement the panic mechanics and police AI response system, including bubble-based propagation, police entity spawning, and player chase behaviors.",
        "details": "1. **Panic System Controllers**: Implement `PanicBubbleController` to create localized spheres of alarm triggered by 'bite', 'kill', or 'witness' events. Develop `PanicPropagationController` to manage state transitions for `HumanNpc` entities within these bubbles, moving them from WANDER to a new PANIC state (faster, erratic movement).\n2. **Police Entities**: Create a `PoliceNpc` class in `src/entities/police.ts` extending the base NPC class. Use the 'Police' sprite sheet from Task 2. \n3. **Police Spawner**: Implement a `PoliceSpawner` that triggers when 'Heat' levels (from Task 4) cross thresholds or when a Panic Bubble persists. Police should spawn at the edge of the active bubble or just off-screen near the incident site.\n4. **Chase AI**: Develop `PoliceChaseController`. This should utilize the `WorldGrid` (Task 3) to pathfind toward the player's current tile. Implement a simple line-of-sight check; if LOS is broken, police should move to the player's last known position before returning to a search/patrol state.\n5. **Incident Integration**: Wire the 'Bite' action in the main gameplay loop to emit an `IncidentEvent` which the `PanicBubbleController` listens for.\n\nDefinition of Done:\n- Panic bubbles are created for incidents and propagate to nearby NPCs.\n- Police spawn locally from panic bubbles and chase player.\n- Police behavior uses world grid/LOS and remains local to incident.",
        "testStrategy": "1. **Panic Propagation Test**: Trigger a 'bite' incident near a group of NPCs and verify that all NPCs within the defined radius transition to the PANIC state and flee from the incident point.\n2. **Spawn Verification**: Increase 'Heat' through debug commands and confirm that `PoliceNpc` entities are correctly instantiated by the `PoliceSpawner` near the player.\n3. **Chase Behavior Audit**: Confirm that spawned police correctly navigate the `WorldGrid` to intercept the player and update their pathing when the player moves. Verify they stop at 'Obstacles' defined in Task 3.\n4. **UI Integration**: Ensure the 'Heat' bar in the `UIScene` (Task 4) accurately reflects the intensity and duration of active panic bubbles.",
        "status": "done",
        "dependencies": [
          "2",
          "3",
          "4",
          "5"
        ],
        "priority": "high",
        "subtasks": [],
        "complexity": 9,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Generate subtasks for the PanicBubbleController logic, the PoliceNpc entity class, the Heat-based spawning system, and the pathfinding-integrated chase AI.",
        "updatedAt": "2026-02-07T08:40:20.595Z"
      },
      {
        "id": 7,
        "title": "Day/Night Cycle and Sun Damage System Integration",
        "description": "Implement the core temporal cycle managing game time, adjusting NPC behavior via multipliers, and integrating sun damage mechanics based on spatial safety masks.",
        "details": "1. **DayNightController**: Develop a central time manager in `src/core/time.ts` that tracks a 24-hour cycle. Implement configurable time-scale (e.g., 1 real second = 1 game minute). Define phases: DAWN (05:00-07:00), DAY (07:00-17:00), DUSK (17:00-19:00), and NIGHT (19:00-05:00).\n2. **NPC & District Scaling**: Modify the `NpcManager` from Task 5 to apply `densityMultiplier` and `speedMultiplier` based on the active phase. For example, 'Industrial' districts should have near-zero density at NIGHT, while 'Main' districts peak during DAY.\n3. **Sun Damage System**: Create a `SunDamageSystem` that runs during the Scene update. It must query the `WorldGrid` (Task 3) for the `SUN_SAFE` bitmask (bit 2). If the player is in a tile where `SUN_SAFE` is false and the global phase is DAY, apply health reduction. During DAWN/DUSK, apply reduced 'singe' damage.\n4. **HUD & Warning Integration**: Wire the `DayNightController` to the `UIScene` (Task 4). Implement specific 'Dusk' and 'Dawn' warning events that trigger screen tints and UI text warnings ('The sun rises soon...') to signal players to find cover.\n5. **Dynamic Shade Map**: Implement `createDynamicSunShadeMap` which interacts with the 'Shadow' layer from Task 1, adjusting its opacity or tile-tints to visually represent the sun's position and the lethality of the environment.\n\nDefinition of Done:\n- Day/Night controller runs in scene loop with phase changes.\n- NPC density/speed multipliers apply by district and phase.\n- Sun damage applies in day/dusk and safe zones prevent damage.\n- Dusk/Dawn warnings are visible.",
        "testStrategy": "1. **Temporal Logic Test**: Use debug commands to set time to 04:59 and 06:59 to verify phase transitions (NIGHT -> DAWN -> DAY).\n2. **Sun Safety Verification**: Place the player on a 'Ground' tile vs a 'Building' tile at 12:00. Confirm HP loss only occurs on the 'Ground' tile.\n3. **Density Audit**: Verify through the NPC debugger that the active NPC count decreases significantly as the game transitions from DAY to NIGHT in residential areas.\n4. **Visual Alert Test**: Confirm the HUD displays the correct phase-specific warnings 1 game hour before phase changes.",
        "status": "done",
        "dependencies": [
          "1",
          "3",
          "4",
          "5"
        ],
        "priority": "medium",
        "subtasks": [],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Specify subtasks for the central DayNightController, the NPC behavior scaling logic, the spatial sun damage system, and the HUD phase transition alerts.",
        "updatedAt": "2026-02-07T08:42:01.593Z"
      },
      {
        "id": 9,
        "title": "FGA-08 Pixellab AI Graphics Generation",
        "description": "Generate splash background and pixel art assets via Pixellab MCP; store token safely and integrate assets into the game.",
        "details": "Use Pixellab MCP to generate production-ready pixel art assets that replace placeholders. Assets must follow 16x16 grid specs for tiles and sprite sheets. Save files into public/assets and update config if needed.\n\nDefinition of Done:\n- Pixellab token stored in a non-git env file (e.g., .env.pixellab) and gitignore updated.\n- Splash background generated and saved as public/assets/ui/splash-bg.png (portrait 1080x1920).\n- Tileset generated at public/assets/tilesets/town-tiles.png (256x256, 16x16 grid).\n- Player sprite sheet generated at public/assets/sprites/player.png (48x64, 3x4).\n- Humans sprite sheet generated at public/assets/sprites/humans.png (48x320, 5 variants).\n- Police sprite sheet generated at public/assets/sprites/police.png (48x64, 3x4).\n- Phaser loads and renders these assets correctly.",
        "testStrategy": "1. Open the game and confirm splash background shows.\n2. Verify tileset and sprites load without Phaser errors.\n3. Visual check that sprites align to 16x16 grid and animate correctly.",
        "status": "done",
        "dependencies": [
          "2"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Store Pixellab token securely",
            "description": "Add .env.pixellab (AUTH_HEADER) and ensure .gitignore excludes it; add placeholder to .env.example.",
            "dependencies": [],
            "details": "Token must be stored in project but excluded from git.",
            "status": "done",
            "testStrategy": "Verify .env.pixellab is present and git status does not track it.",
            "parentId": "9"
          },
          {
            "id": 2,
            "title": "Generate splash background",
            "description": "Use Pixellab MCP to generate a dark, atmospheric splash background (moon, mist, silhouettes).",
            "dependencies": [
              1
            ],
            "details": "Output: public/assets/ui/splash-bg.png, 1080x1920 portrait.",
            "status": "done",
            "testStrategy": "Open app; splash screen shows background.",
            "parentId": "9"
          },
          {
            "id": 3,
            "title": "Generate town tileset",
            "description": "Generate 256x256 tileset (16x16 grid) for town layers (roads, buildings, parks, trees).",
            "dependencies": [
              1
            ],
            "details": "Output: public/assets/tilesets/town-tiles.png.",
            "status": "done",
            "testStrategy": "Load a map using tileset; tiles render correctly.",
            "parentId": "9"
          },
          {
            "id": 4,
            "title": "Generate player sprite sheet",
            "description": "Generate player sprite sheet (3x4 frames, 48x64).",
            "dependencies": [
              1
            ],
            "details": "Output: public/assets/sprites/player.png.",
            "status": "done",
            "testStrategy": "Player sprite renders at 16x16 frame size.",
            "parentId": "9"
          },
          {
            "id": 5,
            "title": "Generate humans sprite sheet",
            "description": "Generate humans sheet with variants: child, adult male/female, old male/female (stacked).",
            "dependencies": [
              1
            ],
            "details": "Output: public/assets/sprites/humans.png, 48x320.",
            "status": "done",
            "testStrategy": "Spawn different NPC types; frames align.",
            "parentId": "9"
          },
          {
            "id": 6,
            "title": "Generate police sprite sheet",
            "description": "Generate police sprite sheet (3x4 frames, 48x64).",
            "dependencies": [
              1
            ],
            "details": "Output: public/assets/sprites/police.png.",
            "status": "done",
            "testStrategy": "Police sprite renders and animates.",
            "parentId": "9"
          },
          {
            "id": 7,
            "title": "Integrate assets in game",
            "description": "Replace placeholders and verify Phaser loads all new assets.",
            "dependencies": [
              2,
              3,
              4,
              5,
              6
            ],
            "details": "Update config paths if needed and validate in Town scene.",
            "status": "done",
            "testStrategy": "No Phaser asset load errors; visuals appear.",
            "parentId": "9"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Task is already well-defined with subtasks; no further expansion needed.",
        "updatedAt": "2026-02-08T19:49:43.875Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-02-07T08:42:35.290Z",
      "taskCount": 8,
      "completedCount": 7,
      "tags": [
        "full-game-alpha"
      ],
      "created": "2026-02-09T06:41:50.964Z",
      "description": "Tasks for full-game-alpha context",
      "updated": "2026-02-09T06:41:50.964Z"
    }
  }
}