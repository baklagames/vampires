{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "YAML Config Loader and Validation System",
        "description": "Implement the core configuration system to load, validate, and provide immutable runtime access to game balance parameters.",
        "details": "Create `src/config/loader.ts` and `src/config/schema.ts`. Use a library like `js-yaml` to parse the YAML file and `zod` or `ajv` for schema validation. Ensure the config object is deeply frozen (`Object.freeze`) once loaded to maintain immutability. Parameters include player name rules, NPC density, cycle timers, and bite ranges. \n\n```typescript\n// Pseudo-code snippet\nexport const loadConfig = async (path: string) => {\n  const raw = await fetch(path).then(res => res.text());\n  const data = yaml.load(raw);\n  const validated = ConfigSchema.parse(data);\n  return Object.freeze(validated);\n};\n```",
        "testStrategy": "Unit tests to verify: 1. Successful loading of valid YAML. 2. Validation errors for missing/invalid fields. 3. Proper application of default values. 4. Immutability of the returned object.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Game Configuration Schema and Types",
            "description": "Create a comprehensive Zod schema in src/config/schema.ts for all game balance parameters.",
            "dependencies": [],
            "details": "Implement the schema using Zod to define player name rules, NPC density, cycle timers, and bite ranges. Ensure it includes default values and exports TypeScript types for use throughout the application.",
            "status": "done",
            "testStrategy": "Validate that the Zod schema correctly rejects invalid types and successfully parses a full object of default values.",
            "updatedAt": "2026-02-04T18:01:06.003Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement YAML Loader with Immutability",
            "description": "Develop the logic in src/config/loader.ts to fetch, parse, and freeze the configuration.",
            "dependencies": [
              1
            ],
            "details": "Use js-yaml to parse raw text into JavaScript objects. Implement a utility to deeply freeze the resulting object after Zod validation to ensure the configuration remains immutable during runtime.",
            "status": "done",
            "testStrategy": "Unit tests to verify that the loader returns a deeply frozen object and that attempts to modify it throw errors in strict mode.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T18:08:45.379Z"
          },
          {
            "id": 3,
            "title": "Validation and Human-Friendly Error Reporting",
            "description": "Implement an error handling wrapper to provide clear feedback when configuration files are malformed or invalid.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create a utility to catch Zod validation errors and format them into readable strings. Instead of raw schema errors, show specific messages indicating which field in the YAML file is incorrect and why.",
            "status": "done",
            "testStrategy": "Inject invalid YAML structures and verify that the console/logs output descriptive errors that would allow a designer to fix the file.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T18:09:23.813Z"
          },
          {
            "id": 4,
            "title": "Create Sample Configs and Integration Tests",
            "description": "Provide baseline configuration files and perform full system integration testing of the loader.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create assets/config/default.yaml containing standard game balance. Write integration tests that simulate fetching this file, validating it, and checking the resulting object against expected values.",
            "status": "done",
            "testStrategy": "Execute a full test suite checking: 1. Successful loading. 2. Default value application. 3. Handling of missing files. 4. Handling of invalid YAML syntax.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T18:13:42.537Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down the YAML config loader into: 1. Schema definition using Zod for all game parameters. 2. Implementation of the loader with file system/fetch logic. 3. Unit tests for validation and immutability.",
        "updatedAt": "2026-02-04T18:13:42.537Z"
      },
      {
        "id": 2,
        "title": "Design System Tokens and Color Roles",
        "description": "Establish the foundational UI tokens and color roles for consistent styling across all screens and components.",
        "details": "Implement `src/ui/tokens.ts` defining spacing, typography, radii, and color palettes (e.g., semantic roles like 'danger', 'stealth-active', 'sun-warning'). These tokens must be used by all subsequent UI components. \n\n```typescript\nexport const TOKENS = {\n  colors: { primary: '#6200ee', sunDamage: '#ffeb3b', panic: '#f44336' },\n  spacing: { sm: 4, md: 8, lg: 16 },\n  radius: { default: 4 }\n};\n```",
        "testStrategy": "Visual verification that CSS variables or JS constants match the design specs. Automated linting check to ensure no hardcoded hex colors are used in UI files.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Core UI Tokens and Semantic Color Roles",
            "description": "Create the src/ui/tokens.ts file to store all foundational design constants including spacing, typography, radii, and semantic color palettes.",
            "dependencies": [],
            "details": "Implement the TOKENS object containing colors (primary, sunDamage, panic, danger, stealth-active, sun-warning), spacing (sm, md, lg), and radius. Use TypeScript interfaces to ensure type safety for all design constants.",
            "status": "done",
            "testStrategy": "Manual verification of the object structure and unit tests to ensure all required token keys are exported and values match design specifications.",
            "updatedAt": "2026-02-04T18:20:29.326Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Token Enforcement Utility and Linting Check",
            "description": "Create a mechanism to ensure developers use the defined tokens instead of hardcoded hex values or raw pixel numbers in UI components.",
            "dependencies": [
              1
            ],
            "details": "Develop a helper function or custom theme provider to access tokens. Configure an ESLint rule or provide a script to scan src/ui/ for hardcoded hex colors or direct numerical spacing values to enforce token usage.",
            "status": "done",
            "testStrategy": "Run an automated linting check against a test component containing hardcoded colors to confirm the enforcement mechanism identifies violations.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T18:21:49.011Z"
          }
        ],
        "complexity": 2,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Split this into: 1. Definition of the token object structure. 2. Implementation of a linting rule or helper function to enforce token usage in UI components.",
        "updatedAt": "2026-02-04T18:21:49.011Z"
      },
      {
        "id": 3,
        "title": "Pathfinding and Sun-Shade Map Systems",
        "description": "Implement the spatial logic for NPC/Player movement and detection of sunlit versus shaded areas.",
        "details": "Create `src/systems/pathfinding.ts` using Phaser's built-in A* or a custom grid-based pathfinder. Implement `src/systems/sun-shade-map.ts` which takes a tilemap and identifies 'safe' zones (interiors, shadows) versus 'danger' zones based on time of day. This will use the runtime config for damage intervals.",
        "testStrategy": "Integration tests: 1. Pathfinding returns valid paths around obstacles. 2. Sun-Shade map correctly identifies a tile as 'shaded' when under a building or during night.",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Grid-Based Pathfinding System",
            "description": "Develop the core pathfinding logic in src/systems/pathfinding.ts using A* to enable NPC and player movement.",
            "dependencies": [],
            "details": "Integrate Phaser's navigation capabilities or an A* library to calculate paths across the tilemap. Map tile collisions and 'unwalkable' properties to the pathfinder grid.",
            "status": "done",
            "testStrategy": "Unit test: Verify that the pathfinding algorithm returns a valid list of coordinates between two points and correctly avoids collision tiles.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T18:32:51.101Z"
          },
          {
            "id": 2,
            "title": "Develop Sun-Shade Mapping Logic",
            "description": "Create src/systems/sun-shade-map.ts to differentiate between sunlit and shaded tilemap areas.",
            "dependencies": [],
            "details": "Iterate through the tilemap layers to identify tiles marked as 'interior' or 'shadow' based on metadata. Define a boolean mask for the current level's safety zones.",
            "status": "done",
            "testStrategy": "Integration test: Confirm that tiles located under building sprites or inside designated interior layers are flagged as 'safe' zones.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T18:37:40.315Z"
          },
          {
            "id": 3,
            "title": "Integrate Dynamic Safe Zone Transitions",
            "description": "Sync the sun-shade map with the Day/Night Cycle controller to update safety status in real-time.",
            "dependencies": [
              2
            ],
            "details": "Listen for Phase events from the Day/Night controller. Adjust the sun-shade map so that all outdoor tiles become 'safe' during Night and 'danger' during Day, with transitions at Dawn/Dusk.",
            "status": "done",
            "testStrategy": "Integration test: Simulate a cycle transition and verify that the safety status of a specific outdoor tile changes when the phase moves from Day to Night.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T18:40:11.198Z"
          },
          {
            "id": 4,
            "title": "Optimize and Profile Tilemap Scanning",
            "description": "Perform performance profiling on the spatial logic systems to ensure smooth execution on mobile devices.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Profile the frequency of map-wide updates using Chrome DevTools. Implement optimizations such as caching safe-zone results or using bitwise operations for grid scanning to maintain 60 FPS.",
            "status": "done",
            "testStrategy": "Performance test: Measure the execution time of the sun-shade update logic to ensure it stays below the 16ms frame budget during scene updates.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T18:41:08.763Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Separate the spatial logic into: 1. Integration of Phaser A* for NPC movement. 2. Implementation of the sun-shade mapping logic (tile-based shadow detection). 3. Dynamic updating of safe zones based on the game clock. 4. Performance profiling for tilemap scanning.",
        "updatedAt": "2026-02-04T18:41:08.763Z"
      },
      {
        "id": 4,
        "title": "Day/Night Cycle Controller",
        "description": "Implement the logic for transitioning between Day, Dusk, Night, and Dawn phases.",
        "details": "Create `src/controllers/day-night.ts`. It should manage a global timer and update the current 'Phase'. It triggers events that other systems (like NPC density or Police Response) listen to. Transitions should provide visual warnings (Dusk/Dawn) as per PRD.",
        "testStrategy": "Unit tests for state transitions: Day -> Dusk -> Night -> Dawn -> Day. Verify multipliers for NPC density are correctly calculated based on the active phase.",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Core Time Progression and Phase State Machine",
            "description": "Implement the fundamental time-tracking logic and state transitions for the cycle.",
            "dependencies": [],
            "details": "Develop the internal clock and state machine in src/controllers/day-night.ts to manage transitions between Day, Dusk, Night, and Dawn phases based on a configurable global timer.",
            "status": "done",
            "testStrategy": "Unit tests to verify that the internal clock correctly triggers phase transitions at designated intervals (e.g., Day -> Dusk).",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T18:46:08.490Z"
          },
          {
            "id": 2,
            "title": "Phase Transition Event Emitter System",
            "description": "Create a robust event-driven architecture for notifying external systems of cycle changes.",
            "dependencies": [
              1
            ],
            "details": "Implement an EventEmitter within the controller to broadcast 'phaseChange' signals. This allows systems like the UI, NPC Manager, and Police Response to react dynamically to time changes.",
            "status": "done",
            "testStrategy": "Integration tests using mock listeners to confirm that events are emitted with the correct phase data exactly when a transition occurs.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:02:02.160Z"
          },
          {
            "id": 3,
            "title": "NPC Density and Police Multiplier Logic",
            "description": "Calculate and expose environmental modifiers based on the active cycle phase.",
            "dependencies": [
              1
            ],
            "details": "Implement getter methods or data structures that provide multipliers for NPC density and police aggression levels tailored to each phase (e.g., lower NPC density during Night, higher police presence during Day).",
            "status": "done",
            "testStrategy": "Validation tests to ensure that the getDensityMultiplier() and getPoliceMultiplier() methods return the values defined in the game configuration for each state.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:04:32.477Z"
          },
          {
            "id": 4,
            "title": "Scene FX and UI Warning Integration",
            "description": "Connect the controller to the visual systems to provide visual feedback and warnings.",
            "dependencies": [
              1,
              2
            ],
            "details": "Integrate the controller with the rendering engine to adjust global lighting (FX) and trigger 'Dusk/Dawn' warning UI components to alert players of impending environmental changes.",
            "status": "done",
            "testStrategy": "Manual verification in-game to observe smooth lighting transitions and the correct display of warning banners during the transitional Dusk and Dawn phases.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:06:23.760Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Divide the controller into: 1. Core state machine for cycle phases. 2. Event emitter system for phase transitions. 3. NPC density multiplier calculator based on the current phase.",
        "updatedAt": "2026-02-04T19:06:23.760Z"
      },
      {
        "id": 5,
        "title": "Panic Bubble and Police Response Logic",
        "description": "Develop the local panic mechanics and the resulting police spawning system.",
        "details": "Implement `src/controllers/panic-bubble.ts` to manage circular areas of effect around incidents. Implement `src/controllers/police-response.ts` to spawn police NPCs within or near the panic bubble. Use config for bubble radius, duration, and the 'night x2' multiplier for police response density.",
        "testStrategy": "Simulate an incident and verify: 1. Panic state only spreads to NPCs within the radius. 2. Police spawn count increases correctly during Night phase vs Day phase.",
        "priority": "medium",
        "dependencies": [
          "1",
          "4"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Panic Bubble Lifecycle and State Management",
            "description": "Create the core manager for panic bubbles, handling their creation, duration-based expiration, and spatial tracking.",
            "dependencies": [],
            "details": "Implement the PanicBubbleManager in src/controllers/panic-bubble.ts. It should store a collection of active bubbles (x, y, radius, remainingDuration) and include a cleanup loop to remove expired bubbles.",
            "status": "done",
            "testStrategy": "Unit test to verify that adding a bubble with a 5-second duration results in its removal from the active state after exactly 5 seconds.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:16:20.826Z"
          },
          {
            "id": 2,
            "title": "Develop AoE Logic for NPC Panic State Spread",
            "description": "Develop the spatial logic to detect NPCs within the radius of active bubbles and update their behavior state.",
            "dependencies": [
              1
            ],
            "details": "Implement a collision or distance-check routine that iterates through active bubbles and identifies all NPCs within the radius. Trigger the 'panic' state on the NPC instances to modify their movement speed or pathing.",
            "status": "done",
            "testStrategy": "Integration test: Place an NPC at distance R-1 and another at R+1 from the bubble center; verify only the first NPC enters the panic state.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:17:13.210Z"
          },
          {
            "id": 3,
            "title": "Implement Police Spawning Controller and Location Logic",
            "description": "Create the spawning system that generates police NPCs at valid locations near or within panic bubbles.",
            "dependencies": [
              1
            ],
            "details": "Implement src/controllers/police-response.ts. This controller must query the map for valid, walkable tiles near the panic bubble center and instantiate Police NPC objects at a rate defined by the config.",
            "status": "done",
            "testStrategy": "Verify that police NPCs are instantiated at coordinates within 20% of the bubble radius and that they are placed on valid navigation tiles.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:18:31.042Z"
          },
          {
            "id": 4,
            "title": "Integrate Night-time Multiplier and Config Parameters",
            "description": "Adjust police spawn density and frequency based on the global configuration and current day/night phase.",
            "dependencies": [
              3
            ],
            "details": "Access the global YAML configuration for base spawn rates and radius. Implement logic to double (x2) the spawn density when the current game state is set to 'Night' phase.",
            "status": "done",
            "testStrategy": "Manual test: Trigger a panic bubble during the Day phase and count spawns, then repeat during the Night phase to confirm the count is exactly doubled.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:19:27.908Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Detail the panic mechanics: 1. Area-of-effect (AoE) logic for panic spread. 2. Police spawn algorithm (location selection and frequency). 3. State management for active bubbles. 4. Night-time multiplier implementation.",
        "updatedAt": "2026-02-04T19:19:27.908Z"
      },
      {
        "id": 6,
        "title": "One-Handed Tap-to-Move and Stealth Interaction",
        "description": "Implement the primary mobile control scheme for movement, target selection, and feeding.",
        "details": "Create the input handling logic in a base player class. Tapping empty space moves the player. Tapping an NPC selects them as a target (showing a TargetRingFlash). Tapping the target again while in range initiates the 'Bite' (feeding) action. All timings and ranges must come from `RuntimeConfig`.",
        "testStrategy": "Manual testing in mobile emulator: 1. Tap to move works. 2. NPC selection/deselection via tap works. 3. Feeding logic triggers correctly when within the YAML-defined range.",
        "priority": "high",
        "dependencies": [
          "1",
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Tap-to-Move Input Handler",
            "description": "Handle screen taps on empty tiles to calculate paths and initiate player movement using the pathfinding system.",
            "dependencies": [],
            "details": "Integrate with the pathfinding system created in Task 3. On screen tap, convert pointer coordinates to tile coordinates and request a path for the player character. Movement speed must be fetched from the RuntimeConfig loaded in Task 1.",
            "status": "done",
            "testStrategy": "Manual testing in emulator: confirm player moves to the tapped location and correctly navigates around static obstacles.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:20:59.919Z"
          },
          {
            "id": 2,
            "title": "Develop NPC Selection and Targeting Logic",
            "description": "Differentiate between movement taps and NPC interaction taps to manage the current active target.",
            "dependencies": [
              1
            ],
            "details": "Implement a hit-detection check on input. If an NPC sprite is tapped, set that NPC as the active target. If the ground is tapped, trigger movement instead. Selection must be stored in the base player class to allow for subsequent interaction checks.",
            "status": "done",
            "testStrategy": "Verify that tapping an NPC sets them as target and tapping a different NPC updates the target, while tapping empty space clears it or triggers movement.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:22:48.515Z"
          },
          {
            "id": 3,
            "title": "Create 'Bite' Action State Machine",
            "description": "Implement the logic for the feeding interaction, including range verification and state transitions.",
            "dependencies": [
              2
            ],
            "details": "Define a state machine for the feeding interaction. When the active target is tapped again, check if the distance to the NPC is within the 'biteRange' defined in RuntimeConfig. If within range, transition to the feeding state and trigger the relevant game logic.",
            "status": "done",
            "testStrategy": "Unit test distance check logic; manual test to ensure 'Bite' action only triggers when the player is sufficiently close to the selected NPC.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:23:41.743Z"
          },
          {
            "id": 4,
            "title": "Implement TargetRingFlash Visual Feedback",
            "description": "Create and manage the visual indicator that appears when an NPC is selected or interacted with.",
            "dependencies": [
              2
            ],
            "details": "Create a reusable TargetRingFlash graphic that attaches to the selected NPC's position. This visual must update its visibility based on the selection state and play a specific animation (flash or pulse) when the feeding interaction begins.",
            "status": "done",
            "testStrategy": "Visual inspection: Ensure the ring correctly follows the NPC and plays its animation during the selection and bite phases.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:24:25.824Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down the mobile controls into: 1. Tap-to-move input handler with pathfinder integration. 2. NPC selection/targeting logic (tap vs. movement). 3. The 'Bite' action state machine and range checking. 4. Visual feedback (TargetRingFlash) implementation.",
        "updatedAt": "2026-02-04T19:24:25.824Z"
      },
      {
        "id": 7,
        "title": "Town Scene: Core World Implementation",
        "description": "Assemble the primary game world (Town) with NPCs, tilemaps, and active controllers.",
        "details": "Implement `src/scenes/town.ts`. Integrate the Tilemap, Player character, NPC pooling, and the DayNight/Panic/Police controllers. This scene acts as the main gameplay loop container where 'move -> bite -> panic -> escape' occurs.",
        "testStrategy": "Playtest the full loop: Start in town, find NPC, bite, trigger panic bubble, observe police spawning, and escape to a safe zone.",
        "priority": "high",
        "dependencies": [
          "4",
          "5",
          "6"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Town Scene Lifecycle and Asset Initialization",
            "description": "Establish the foundational structure of the Town scene and load necessary graphical assets for the environment.",
            "dependencies": [],
            "details": "Implement the preload() and create() methods in src/scenes/town.ts. Load the Tiled JSON map, tilesets, and sprite sheets for the player and NPCs. Ensure the camera is initialized to follow the player character.",
            "status": "done",
            "testStrategy": "Verify that the game loads without errors and the town tilemap is rendered correctly in the browser.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:26:36.592Z"
          },
          {
            "id": 2,
            "title": "NPC Pool Integration and Spawning Logic",
            "description": "Integrate the NPC pooling system into the Town scene to manage entity lifecycles efficiently.",
            "dependencies": [
              1
            ],
            "details": "Initialize the NPC pool within the Town scene. Implement a spawning algorithm that places NPCs on walkable tilemap coordinates, respecting the density multipliers provided by the Day/Night controller.",
            "status": "done",
            "testStrategy": "Observe that NPCs are spawned upon scene start and that the number of NPCs matches the expected density for the current time phase.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:28:51.189Z"
          },
          {
            "id": 3,
            "title": "System Orchestration and Event Bus Setup",
            "description": "Connect the Day/Night, Panic, and Police controllers to the Town scene's update loop.",
            "dependencies": [
              1
            ],
            "details": "Instantiate the DayNightController, PanicController, and PoliceController. Set up event listeners within the scene to handle phase shifts (e.g., changing ambient light) and panic escalations (e.g., triggering police spawns).",
            "status": "done",
            "testStrategy": "Trigger a simulated phase change via the console and verify that the scene's ambient tint and NPC behavior update accordingly.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:29:33.738Z"
          },
          {
            "id": 4,
            "title": "Physics Collision and Interaction Layer Configuration",
            "description": "Configure the physics engine to handle collisions between the player, tilemap obstacles, and NPCs.",
            "dependencies": [
              1,
              2
            ],
            "details": "Set up Phaser Arcade Physics or Matter.js to handle collisions with the 'Obstacles' layer of the tilemap. Implement trigger zones for the 'Bite' mechanic and ensure the player cannot pass through buildings or scene boundaries.",
            "status": "done",
            "testStrategy": "Perform manual movement tests to ensure the player character is blocked by walls and can trigger interaction prompts when near NPCs.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:30:10.743Z"
          },
          {
            "id": 5,
            "title": "Debug Overlay and Spatial System Validation",
            "description": "Implement a debug toggle to visualize spatial systems, pathfinding nodes, and collision boundaries.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create a UI overlay that renders physics bodies, NPC detection radii, and current controller states (Time, Panic Level, Active Police Count). This will be used for balancing the 'move -> bite -> escape' gameplay loop.",
            "status": "done",
            "testStrategy": "Toggle the debug view and confirm that collision boxes align with visual assets and that NPC state labels update in real-time.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:30:48.177Z"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Structure the core scene implementation: 1. Scene lifecycle management and asset loading. 2. Integration of NPC pooling for performance. 3. Controller orchestration (Day/Night, Panic, Police). 4. Player-world collision and interaction setup. 5. Debug overlay for spatial systems.",
        "updatedAt": "2026-02-04T19:30:48.177Z"
      },
      {
        "id": 8,
        "title": "Interior and Castle Scenes with Respawn Logic",
        "description": "Implement secondary scenes and the transition logic between them, including the death/respawn flow.",
        "details": "Create `src/scenes/interior.ts` and `src/scenes/castle.ts`. The Castle serves as the safe-zone/respawn point. Use a scene manager to handle transitions. If health reaches zero in the Town or Sun, the player must respawn in the Castle scene.",
        "testStrategy": "Verify scene transitions: 1. Entering a building switches to InteriorScene. 2. Dying in Town correctly triggers transition to CastleScene.",
        "priority": "medium",
        "dependencies": [
          "7"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Scene Transition Manager and State Persistence",
            "description": "Create a centralized manager to handle scene switching and data preservation between map segments.",
            "dependencies": [],
            "details": "Develop a utility to wrap Phaser's Scene Manager to pass player state (health, inventory) between Town, Interior, and Castle scenes efficiently.",
            "status": "done",
            "testStrategy": "Verify that player health values and state variables remain consistent when moving from the Town scene to an Interior scene and back.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:34:30.869Z"
          },
          {
            "id": 2,
            "title": "Create Interior and Castle Scene Classes with Tilemap Support",
            "description": "Implement the specific Scene classes for building interiors and the central castle safe-zone.",
            "dependencies": [
              1
            ],
            "details": "Construct src/scenes/interior.ts and src/scenes/castle.ts. Set up tilemap loading, collision layers, and exit portals that trigger the Scene Manager to return to the Town.",
            "status": "done",
            "testStrategy": "Manually trigger scene transitions via portal overlaps and confirm the correct Tiled assets are rendered for both the Castle and building interiors.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:36:33.828Z"
          },
          {
            "id": 3,
            "title": "Develop Death and Respawn Flow to Castle Scene",
            "description": "Implement the gameplay logic to trigger a respawn in the Castle when health reaches zero.",
            "dependencies": [
              1,
              2
            ],
            "details": "Add a listener to the player state for health reaching 0. Upon death, trigger a fade-out animation and invoke the Scene Manager to move the player to the Castle spawn coordinates.",
            "status": "done",
            "testStrategy": "Simulate player death in the Town scene by reducing health to zero and confirm the game successfully reloads the player at the designated Castle spawn point with reset health.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:37:11.423Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Expand into: 1. Scene transition manager for handling data persistence between scenes. 2. Implementation of Interior and Castle tilemap logic. 3. Death and Respawn flow (Health 0 -> Castle transition).",
        "updatedAt": "2026-02-04T19:37:11.423Z"
      },
      {
        "id": 9,
        "title": "UI Components and Game Overlays (S1-S9 HUD)",
        "description": "Create the Design System-based UI components and in-game overlays like the Blood bar, Phase indicator, and Panic flash.",
        "details": "Implement components in `src/ui/components/` and `src/ui/overlays/`. Include `BottomActionBar`, `TimeOfDayIndicator`, and full-screen flashes for damage/panic. These must use the tokens defined in Task 2. Use Phaser DOM elements or React/Vue overlay if specified by the stack.",
        "testStrategy": "Visual check: 1. UI elements scale for mobile portrait. 2. Phase indicator updates when Day/Night controller changes state. 3. Panic overlay flashes when the player is in a Panic Bubble.",
        "priority": "medium",
        "dependencies": [
          "2",
          "7"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Dynamic Blood Bar and Player Status Component",
            "description": "Create a UI component that visually represents the player's current blood and health levels using design system tokens.",
            "dependencies": [],
            "details": "Implement in `src/ui/components/BloodBar.ts`. Use `TOKENS.colors` for health states (e.g., critical, caution, healthy). The component must support smooth value transitions and scale for high-density mobile displays.",
            "status": "done",
            "testStrategy": "Unit test using a mock player state; verify that the bar width and color accurately reflect percentage thresholds from 0 to 100.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:42:17.015Z"
          },
          {
            "id": 2,
            "title": "Create Phase Indicator Linked to Day/Night Controller",
            "description": "Develop the TimeOfDayIndicator component that updates based on the global game cycle phase.",
            "dependencies": [],
            "details": "Implement in `src/ui/components/PhaseIndicator.ts`. This component must subscribe to the state of the Day/Night controller from Task 4 and display the current phase (Day, Dusk, Night, Dawn) using relevant icons and labels.",
            "status": "done",
            "testStrategy": "Integration test: manually trigger phase transitions in the controller and confirm the UI label and icon update immediately.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:42:54.437Z"
          },
          {
            "id": 3,
            "title": "Implement Full-Screen Damage and Panic Flash Overlays",
            "description": "Develop visual feedback overlays that trigger on damage or when entering panic zones.",
            "dependencies": [],
            "details": "Create `src/ui/overlays/FlashOverlay.ts`. Implement a full-screen alpha-rect or shader that flashes 'panic' red or 'sun damage' yellow when specific events are fired from the game engine.",
            "status": "done",
            "testStrategy": "Visual verification: trigger the panic event in-game and ensure the screen-wide flash occurs without obstructing UI controls.",
            "parentId": "undefined",
            "updatedAt": "2026-02-04T19:43:29.743Z"
          },
          {
            "id": 4,
            "title": "Assemble Responsive HUD Layout and Action Bar",
            "description": "Combine components into a cohesive HUD layout optimized for mobile portrait orientation.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Implement the main HUD container in `src/ui/HUDContainer.ts`. Include the `BottomActionBar` and use a layout system (CSS Flexbox or Phaser DOM) to ensure components are positioned correctly within mobile safe areas.",
            "status": "done",
            "testStrategy": "Responsiveness check: Verify that the HUD layout scales correctly across multiple mobile device aspect ratios (e.g., iPhone SE vs iPhone 14 Pro Max).",
            "parentId": "undefined",
            "updatedAt": "2026-02-05T08:04:21.167Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down the HUD: 1. Dynamic Blood Bar component. 2. Phase indicator linked to the Day/Night controller. 3. Full-screen damage/panic flash effects. 4. Responsive layout system for mobile portrait mode.",
        "updatedAt": "2026-02-05T08:04:21.167Z"
      },
      {
        "id": 10,
        "title": "Navigation and Screen Management (S0-S10)",
        "description": "Implement the complete set of screens (Main Menu, Settings, Game Over) and the navigation flow.",
        "details": "Implement the remaining screens (S0: Splash, S1: Main Menu, S10: Settings, etc.). Create a navigation controller that handles transitions between menus and scenes. Ensure the player name validation rules (Task 1) are applied on the profile/start screen.",
        "testStrategy": "End-to-End test: Boot the game, navigate from Splash to Main Menu, enter Settings, return, start game, trigger Game Over, and return to Menu.",
        "priority": "medium",
        "dependencies": [
          "1",
          "9"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Centralized Navigation Controller and Screen Router",
            "description": "Implement the core navigation manager to handle screen transitions, stack management, and scene switching for screens S0-S10.",
            "dependencies": [],
            "details": "Create a NavigationController class that maintains a screen stack. Implement logic to switch between Phaser scenes or UI layers, including fade-in/out transitions and state preservation for active scenes.",
            "status": "done",
            "testStrategy": "Unit test the router's stack logic to ensure push/pop operations maintain correct hierarchy and scene events are dispatched.",
            "parentId": "undefined",
            "updatedAt": "2026-02-05T08:16:20.984Z"
          },
          {
            "id": 2,
            "title": "UI Implementation for Splash, Main Menu, and Settings Screens",
            "description": "Develop the visual layouts for S0 (Splash), S1 (Main Menu), and S10 (Settings) using the project design tokens.",
            "dependencies": [
              1
            ],
            "details": "Build the screens using UI tokens from Task 2. Integrate the player name validation logic (Task 1) into the profile section. Ensure the Settings screen correctly interacts with the GameConfig/RuntimeConfig.",
            "status": "done",
            "testStrategy": "Manual visual verification against design specs and automated validation check to ensure name input rejects invalid strings.",
            "parentId": "undefined",
            "updatedAt": "2026-02-05T08:17:19.065Z"
          },
          {
            "id": 3,
            "title": "Input Handling, State Persistence, and Smoke Testing",
            "description": "Implement global back-button handling, settings persistence, and perform full-flow integration tests.",
            "dependencies": [
              1,
              2
            ],
            "details": "Map hardware back-button inputs to navigation 'pop' events. Implement local storage persistence for user settings. Execute an end-to-end smoke test covering the flow: Splash -> Menu -> Settings -> Game -> Game Over.",
            "status": "done",
            "testStrategy": "End-to-End test: Verify that navigating through the entire screen flow and returning to the menu works without memory leaks or state corruption.",
            "parentId": "undefined",
            "updatedAt": "2026-02-05T08:18:07.414Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Detail the menu flow: 1. Centralized navigation controller/router. 2. Implementation of Splash, Main, and Settings screens. 3. Validation logic for player names based on YAML config.",
        "updatedAt": "2026-02-05T08:18:07.414Z"
      },
      {
        "id": 11,
        "title": "Local Run / Demo Build Harness",
        "description": "Enable local dev and demo build for running the game.",
        "details": "Add a minimal bootstrapping entrypoint (e.g., src/main.ts) that creates the Phaser game instance and wires initial scenes/navigation. Add a local dev server and build/preview scripts (e.g., Vite). Add index.html container and document run/build steps in README. Ensure config loader and design tokens are integrated at boot.",
        "testStrategy": "Smoke test: run dev server, confirm game boots to splash/menu; run build/preview and confirm a playable demo loads without console errors.",
        "priority": "medium",
        "dependencies": [
          "10"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Setup Vite Build System and index.html",
            "description": "Configure the local development environment and build pipeline using Vite.",
            "dependencies": [],
            "details": "Install Vite as a dev dependency. Create a root 'index.html' that includes a container element for the Phaser canvas and scripts for 'src/main.ts'. Update 'package.json' with 'dev', 'build', and 'preview' commands to facilitate rapid development and demo packaging.",
            "status": "done",
            "testStrategy": "Verify that 'npm run dev' successfully launches a browser tab and 'npm run build' generates a 'dist' folder without errors.",
            "parentId": "undefined",
            "updatedAt": "2026-02-05T08:41:00.279Z"
          },
          {
            "id": 2,
            "title": "Implement Phaser Main Entrypoint and Configuration Bootstrapping",
            "description": "Create the primary bootstrapping logic in src/main.ts to initialize the game and load global configurations.",
            "dependencies": [
              1
            ],
            "details": "Implement 'src/main.ts' to invoke the YAML config loader (Task 1) and register Design System Tokens (Task 2). Initialize the Phaser.Game instance with appropriate configuration (physics, scaling, rendering). Wire the first scene provided by the Navigation Controller (Task 10).",
            "status": "done",
            "testStrategy": "Check the browser console during startup to ensure the frozen config object is loaded and design tokens are applied to the game canvas/DOM.",
            "parentId": "undefined",
            "updatedAt": "2026-02-05T08:42:08.531Z"
          },
          {
            "id": 3,
            "title": "Project Documentation and Build Harness Verification",
            "description": "Document the setup process in the README and perform a final smoke test of the integrated harness.",
            "dependencies": [
              2
            ],
            "details": "Create or update 'README.md' with clear instructions on prerequisites, installation, and run/build steps. Verify that the build artifact (Vite build) correctly loads the game, navigates to the splash screen, and handles asset loading via the local harness.",
            "status": "done",
            "testStrategy": "Run 'npm run build' followed by 'npm run preview' and manually verify the game boots to the Main Menu (S1) as per the navigation flow.",
            "parentId": "undefined",
            "updatedAt": "2026-02-05T08:47:52.598Z"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break down into: 1) Add bundler/dev server + scripts. 2) Add Phaser boot entrypoint and scene wiring. 3) Document run/build instructions and smoke-test checklist.",
        "updatedAt": "2026-02-05T08:47:52.598Z"
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-02-05T08:47:52.598Z",
      "taskCount": 11,
      "completedCount": 11,
      "tags": [
        "master"
      ],
      "created": "2026-02-05T14:46:54.301Z",
      "description": "Tasks for master context",
      "updated": "2026-02-05T14:46:54.301Z"
    }
  },
  "mvp-full": {
    "tasks": [
      {
        "id": "1",
        "title": "MVP-01 Config Expansion",
        "description": "Expand GameConfig + assets/config/default.yaml to full PRD knobs. Add sections for player stats/blood/actions, NPC behavior/detection, police behavior, heat increase, UI timing, upgrades, maps. Ensure defaults in YAML and no gameplay constants in code.",
        "details": "Test Strategy: schema parse + YAML load + unit tests covering defaults.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "subtasks": [],
        "complexity": 3,
        "recommendedSubtasks": 3,
        "expansionPrompt": "1. Create types/interfaces for the new config sections (Player, NPC, Police, UI, Upgrades).\n2. Update the default YAML file with PRD values.\n3. Implement a schema validation layer (e.g., Zod) to ensure loaded config matches types.",
        "updatedAt": "2026-02-05T17:09:28.580Z"
      },
      {
        "id": "2",
        "title": "MVP-02 DS Tokens v2 + CSS Vars",
        "description": "Align design tokens with PRD (spacing/radius/typography/color roles), add CSS variables for tokens, enforce semantic color roles.",
        "details": "Test Strategy: token enforcement tests pass; no hardcoded layout/color values in UI files.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          "1"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Design Token Registry (JSON/TS)",
            "description": "Map PRD specifications for colors, spacing, radius, and typography into a structured JSON or TypeScript configuration to serve as the single source of truth.",
            "dependencies": [],
            "details": "Establish a comprehensive registry containing semantic color roles (primary, secondary, feedback), spacing scales, and typography definitions. This registry must export structured objects compatible with the injection utility and component library.",
            "status": "done",
            "testStrategy": "Schema validation and type checks to ensure all required PRD tokens are present and formatted correctly.",
            "updatedAt": "2026-02-05T18:49:06.831Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement CSS Variable Injection Utility",
            "description": "Develop a utility function to transform the design token registry into CSS custom properties and inject them into the application's global stylesheet.",
            "dependencies": [
              1
            ],
            "details": "Iterate through the token registry to generate a valid CSS string for the :root selector. The utility should handle nested objects to create kebab-case variable names (e.g., --ds-color-primary-main) and append the styles to the document head.",
            "status": "done",
            "testStrategy": "Verify the presence of CSS variables in the DOM using browser inspector and unit test the token-to-CSS string conversion logic.",
            "parentId": "undefined",
            "updatedAt": "2026-02-05T18:54:18.389Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 2,
        "expansionPrompt": "1. Define the token registry (JSON/TS) matching the PRD values for colors, spacing, and typography.\n2. Create a utility to inject these tokens as CSS variables into the global stylesheet.",
        "updatedAt": "2026-02-05T18:54:18.389Z"
      },
      {
        "id": "3",
        "title": "MVP-03 DS Components",
        "description": "Implement DS components per PRD: PixelCard, ButtonPrimary/Secondary/Icon, BottomActionBar, HUDChip, ProgressBar, HeatIndicator, Toast, ModalSheet, ListItem, TextField, ToggleSwitch, TooltipHelp.",
        "details": "Test Strategy: component state/render tests (or UI snapshot checks) for required variants.",
        "testStrategy": "",
        "status": "done",
        "dependencies": [
          "2"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Atomic Buttons and HUDChips",
            "description": "Create the core interactive atomic components: Button (Primary, Secondary, Icon variants) and HUDChip.",
            "dependencies": [],
            "details": "Use Tailwind CSS to implement hover, active, and disabled states. Ensure the Button component supports loading states and icon positioning as seen in the code snippets.",
            "status": "done",
            "testStrategy": "Unit tests for button click handlers and snapshot tests for different variant rendering.",
            "parentId": "undefined",
            "updatedAt": "2026-02-05T18:59:50.309Z"
          },
          {
            "id": 2,
            "title": "Develop Input and Form Control Components",
            "description": "Implement TextField, ToggleSwitch, and TooltipHelp components for user input and guidance.",
            "dependencies": [
              1
            ],
            "details": "Ensure TextField supports focus states and error styling. ToggleSwitch should have smooth transitions and TooltipHelp needs absolute positioning logic.",
            "status": "done",
            "testStrategy": "Interaction testing for toggle state changes and focus/blur behavior for TextFields.",
            "parentId": "undefined",
            "updatedAt": "2026-02-05T19:14:11.296Z"
          },
          {
            "id": 3,
            "title": "Build Feedback and Status Indicators",
            "description": "Implement ProgressBar, HeatIndicator, and Toast components for game state feedback.",
            "dependencies": [
              1
            ],
            "details": "ProgressBar should handle dynamic width updates. HeatIndicator requires specific color gradients for intensity levels. Toast needs a notification queue logic.",
            "status": "done",
            "testStrategy": "Verify ProgressBar width reflects prop percentage and Toast correctly triggers/dismisses.",
            "parentId": "undefined",
            "updatedAt": "2026-02-05T19:17:09.139Z"
          },
          {
            "id": 4,
            "title": "Create Layout and Container Components",
            "description": "Implement the PixelCard and ListItem components to structure data and menus.",
            "dependencies": [
              1
            ],
            "details": "PixelCard should use the specific pixel-art border styling and shadow tokens. ListItem should handle icon slots and click interactions.",
            "status": "done",
            "testStrategy": "UI layout verification to ensure padding and border consistency across different content sizes.",
            "parentId": "undefined",
            "updatedAt": "2026-02-05T19:18:09.593Z"
          },
          {
            "id": 5,
            "title": "Implement Complex Overlay and Action Components",
            "description": "Develop the ModalSheet and BottomActionBar components for high-level UI navigation.",
            "dependencies": [
              1,
              4
            ],
            "details": "ModalSheet must include a backdrop overlay and animation for appearing. BottomActionBar should be fixed to the viewport with z-index management.",
            "status": "done",
            "testStrategy": "Manual verification of modal dismissal behavior and fixed positioning on different screen sizes.",
            "parentId": "undefined",
            "updatedAt": "2026-02-05T19:20:41.554Z"
          },
          {
            "id": 6,
            "title": "Establish Component Gallery and Documentation",
            "description": "Create a gallery page or Storybook setup to visualize all DS components in isolation.",
            "dependencies": [
              1,
              2,
              3,
              4,
              5
            ],
            "details": "Develop a dedicated route or Storybook config that renders every component variant and state (hover, disabled, etc.) for review.",
            "status": "done",
            "testStrategy": "Visual regression check of all components against design specs in the gallery environment.",
            "parentId": "undefined",
            "updatedAt": "2026-02-05T19:46:22.375Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 6,
        "expansionPrompt": "1. Implement atomic components: Button, Chip, TextField, Toggle.\n2. Implement composite components: PixelCard, ModalSheet, BottomActionBar.\n3. Implement game-specific UI: HealthBar/ProgressBar, HeatIndicator.\n4. Create a Storybook or gallery page to visualize components in isolation.",
        "updatedAt": "2026-02-05T19:46:22.375Z"
      },
      {
        "id": "4",
        "title": "MVP-04 Core Player Systems",
        "description": "Implement PlayerController, FeedingSystem, SunDamageSystem, HeatController; all values config-driven; interruptible feeding; sun grace; heat decay.",
        "details": "Test Strategy: unit tests for bite range, damage per second, heat decay.",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          "1"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement PlayerController State Machine",
            "description": "Develop the PlayerController class to manage player states such as idle, moving, feeding, and dead using config-driven values.",
            "dependencies": [],
            "details": "Create a robust state machine that maps user inputs to player actions while ensuring all movement speeds and state durations are pulled from the GameConfig.",
            "status": "pending",
            "testStrategy": "Unit tests for state transitions and input-to-action mapping logic.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Develop Interruptible FeedingSystem",
            "description": "Create the FeedingSystem to handle interaction radius detection, bite logic, and interruptible progress bars.",
            "dependencies": [
              1
            ],
            "details": "Implement logic to calculate bite range and manage a feeding timer that resets if the player moves or takes damage, utilizing interaction constants from the YAML config.",
            "status": "pending",
            "testStrategy": "Unit tests for bite range verification and interruption triggers upon state changes.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement SunDamageSystem with Grace Period",
            "description": "Build a system that applies health damage when the player is exposed to sunlight based on environmental checks.",
            "dependencies": [
              1
            ],
            "details": "Implement a damage-per-second (DPS) logic that includes a 'sun grace' period before damage begins. Logic should be decoupled from the physics engine to allow for tile-based or raycast checks.",
            "status": "pending",
            "testStrategy": "Unit tests for damage application timing and validation of the grace period duration.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Build HeatController and Decay Logic",
            "description": "Implement the HeatController to track global suspicion levels and apply automatic decay over time.",
            "dependencies": [],
            "details": "Develop a controller that tracks 'Heat' as a float value, increasing it based on events and decreasing it using a decay rate defined in the central configuration file.",
            "status": "pending",
            "testStrategy": "Unit tests to verify heat accumulation math and decay rates over a simulated timeline.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integrate Core Systems into Testable Harness",
            "description": "Wire the PlayerController, FeedingSystem, SunDamageSystem, and HeatController into a unified framework-agnostic harness.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Construct a main update loop for these systems that operates independently of Phaser's scene lifecycle, allowing for pure logic testing and easier engine integration later.",
            "status": "pending",
            "testStrategy": "Integration tests ensuring a single update tick correctly propagates through all four sub-systems.",
            "parentId": "undefined"
          }
        ],
        "complexity": 8,
        "recommendedSubtasks": 5,
        "expansionPrompt": "1. Implement PlayerController class managing state and input handling.\n2. Create FeedingSystem handling interaction radius and 'bite' logic.\n3. Implement SunDamageSystem with raycasting or tile-check logic.\n4. Build HeatController to track suspicion levels and decay over time.\n5. Wire these systems into a testable harness independent of Phaser scenes."
      },
      {
        "id": "5",
        "title": "MVP-05 Detection + NPC AI",
        "description": "Implement DetectionController (LOS + distance), NPC state machine (Calm/Suspicious/Alarmed/Panic), and base wandering behavior.",
        "details": "Test Strategy: detection transitions and LOS blocking tests.",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          "4"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Line-of-Sight (LOS) Utility",
            "description": "Develop a utility class to calculate visibility between two points using the game's tilemap data.",
            "dependencies": [],
            "details": "Use a raycasting algorithm or Bresenham's line algorithm to check for collision tiles between the NPC and the player coordinates.",
            "status": "pending",
            "testStrategy": "Run unit tests with a mock tilemap to ensure walls correctly block visibility while empty space allows it.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create NPC Finite State Machine (FSM) Base",
            "description": "Design and implement the abstract base classes for the NPC state machine and individual states.",
            "dependencies": [],
            "details": "Implement a StateMachine class with methods for ChangeState, Update, and handle entry/exit logic for different NPC behaviors.",
            "status": "pending",
            "testStrategy": "Verify that state transitions occur correctly and that Enter/Exit hooks are called in the expected sequence.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Specific NPC States",
            "description": "Develop logic for Idle/Wander, Suspicious (investigate), and Alarmed (flee or alert) states.",
            "dependencies": [
              2
            ],
            "details": "Wander should use random point generation; Suspicious moves toward a noise or last-seen point; Alarmed increases movement speed and alerts neighbors.",
            "status": "pending",
            "testStrategy": "Manual simulation of state transitions triggered by external variables like detection level or proximity.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Create DetectionController Component",
            "description": "Build a component that manages NPC awareness using vision cones, distance, and the LOS utility.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "The controller will calculate awareness gain based on the player's proximity and angle relative to the NPC's forward vector and LOS clear path.",
            "status": "pending",
            "testStrategy": "Integration tests to verify awareness bar increases only when the player is inside the detection cone and LOS is not blocked.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Optimize Neighbor Lookup for AI Communication",
            "description": "Implement a spatial partitioning or grid-based system to efficiently find nearby NPCs for behavior propagation.",
            "dependencies": [
              4
            ],
            "details": "Avoid O(N^2) checks by using a spatial hash or simple grid to let Alarmed NPCs quickly notify nearby units to change their state.",
            "status": "pending",
            "testStrategy": "Measure performance with high NPC counts and verify that 'Alarm' state spreads correctly within a specific radius.",
            "parentId": "undefined"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 5,
        "expansionPrompt": "1. Implement Line-of-Sight (LOS) utility handling tilemap collisions.\n2. Create the NPC State Machine (FSM) base class.\n3. Implement specific states: Idle/Wander, Suspicious (investigate), Alarmed (flee/alert).\n4. Create DetectionController to manage awareness cones/circles for NPCs.\n5. Optimize neighbor lookups for NPC-to-NPC communication."
      },
      {
        "id": "6",
        "title": "MVP-06 Panic + Police",
        "description": "Integrate panic bubble with NPC state changes; police response localized to bubble; night multiplier applied.",
        "details": "Test Strategy: bubble radius affects NPCs only inside; police spawn count respects night multiplier.",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          "5"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Panic Bubble Propagation Logic",
            "description": "Develop the mechanism where a panic event alerts nearby NPCs within a configurable radius.",
            "dependencies": [],
            "details": "Use spatial partitioning or distance checks to transition NPC states from 'Idle' to 'Flee' when within the bubble radius.",
            "status": "pending",
            "testStrategy": "Verify that only NPCs within the designated radius transition to panic states and that the radius matches config values.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Create PoliceSpawner and Heat-Based Logic",
            "description": "Build a spawning system that generates police units based on the current global Heat level and applies night multipliers.",
            "dependencies": [
              1
            ],
            "details": "Calculate spawn count using Heat level and Night Multiplier from game config; ensure police spawn near active panic zones.",
            "status": "pending",
            "testStrategy": "Validate that the police spawn count correctly scales with the night multiplier and global heat level thresholds.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Police AI Chase Behavior",
            "description": "Design the Police AI to track and move toward the player character, distinct from civilian flight patterns.",
            "dependencies": [
              2
            ],
            "details": "Implement pathfinding or steering behaviors that specifically target the player's coordinates when the police unit is in 'Pursuit' mode.",
            "status": "pending",
            "testStrategy": "Observe and confirm that police NPCs move toward the player while civilian NPCs move in the opposite direction.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 3,
        "expansionPrompt": "1. Implement 'Panic Bubble' propagation logic (NPCs alerting nearby NPCs).\n2. Create PoliceSpawner logic based on global Heat level.\n3. Implement basic Police AI (chase player) distinct from Civilian AI (flee)."
      },
      {
        "id": "7",
        "title": "MVP-07 Maps + Placeholder Assets",
        "description": "Add placeholder tilemaps and sprites; 3 districts and 610 interiors; map list stored in config.",
        "details": "Test Strategy: assets load without errors.",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "1. Create Tiled tilemaps for Town, Interior, and Castle using placeholder tilesets.\n2. Define collision layers and spawn points in map data.\n3. Create an AssetLoader service to manage map parsing and sprite loading."
      },
      {
        "id": "8",
        "title": "MVP-08 Phaser Scene Wrappers",
        "description": "Build Phaser scenes for Town/Interior/Castle wired to controllers, input, tilemaps, and transitions. Keep logic outside scenes.",
        "details": "Test Strategy: scene boot + transitions + respawn.",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          "4",
          "7"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Create BaseScene Abstract Class",
            "description": "Establish a foundation class that extends Phaser.Scene to centralize common functionality like input mapping and screen resizing.",
            "dependencies": [],
            "details": "Implement boilerplate for handling standard input events and camera resizing to ensure consistent behavior across all game environments.",
            "status": "pending",
            "testStrategy": "Verify that input listeners are correctly initialized and window resize events trigger appropriate camera adjustments.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Location-Specific Scenes",
            "description": "Develop concrete subclasses for TownScene, InteriorScene, and CastleScene that utilize the BaseScene foundation.",
            "dependencies": [
              1
            ],
            "details": "Initialize tilemaps, tilesets, and layer depths for the Town, Interior, and Castle maps using external JSON configuration data.",
            "status": "pending",
            "testStrategy": "Perform visual verification of scene loading and ensure correct layer sorting for each specific environment.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Develop SceneTransitionManager",
            "description": "Create a centralized manager to handle smooth camera transitions and data persistence between different game locations.",
            "dependencies": [
              2
            ],
            "details": "Implement camera fade-in/out effects and a data passing mechanism to transfer player state (HP, Blood, Heat) between scene changes.",
            "status": "pending",
            "testStrategy": "Execute scene swap commands and assert that transition data reaches the destination scene correctly.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Integrate Logic Controllers into Update Loops",
            "description": "Bridge the decoupled logic controllers (Player, Heat, NPC) into the Phaser scene lifecycle for real-time execution.",
            "dependencies": [
              1,
              2
            ],
            "details": "Wire the Scene's update(time, delta) method to trigger the update cycles of the core systems while maintaining clear decoupling.",
            "status": "pending",
            "testStrategy": "Monitor controller state changes within the scene loop to ensure physics and logic updates occur every frame.",
            "parentId": "undefined"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "1. Create BaseScene class to handle common setup (input, resizing).\n2. Implement TownScene, InteriorScene, CastleScene.\n3. Build a SceneTransitionManager to handle fading and data passing between scenes.\n4. Connect the Logic Controllers (Task 4/5) to the Scene update loops."
      },
      {
        "id": "9",
        "title": "MVP-09 HUD + Overlays",
        "description": "Implement HUD and overlays (TargetRingFlash/Outline, PanicAreaIndicator, SunDangerOverlay, TapMarker, damage/panic flash) using DS tokens; config-driven timings.",
        "details": "Test Strategy: overlay triggers and timings.",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          "3",
          "4"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Establish React-Phaser Overlay Infrastructure",
            "description": "Create the React-based DOM layer positioned over the Phaser canvas and implement the state bridge for game data synchronization.",
            "dependencies": [],
            "details": "Implement a high-performance event bus or store bridge to pass data from the Phaser update loop to React without triggering full app re-renders. Set up the CSS layout to ensure the HUD remains interactive while the game canvas renders underneath.",
            "status": "pending",
            "testStrategy": "Verify React overlay visibility over the canvas and measure latency of state updates from Phaser to the UI layer.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Bind HUD Components to Player State Stores",
            "description": "Integrate DS components like ProgressBar and HUDChip to display real-time Health and Heat levels based on GameConfig values.",
            "dependencies": [
              1
            ],
            "details": "Connect the HUD components to the SunDamageSystem and HeatController data. Use Design System tokens for styling and ensure that bar transitions and chip updates use the config-driven UI timings defined in Task 1.",
            "status": "pending",
            "testStrategy": "Unit test state-to-component mapping and manually verify that health/heat bars reflect in-game changes immediately.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Visual Overlays for Environmental States",
            "description": "Build the full-screen visual indicators for Sun Damage (red vignette), Panic (flashing borders), and UI markers.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create the SunDangerOverlay and PanicAreaIndicator using CSS animations and SVG filters. Implement the TargetRingFlash and TapMarker with configuration-driven durations and easing functions as specified in the game config.",
            "status": "pending",
            "testStrategy": "Trigger specific game states (sun exposure, high heat) and verify that the corresponding overlays activate and deactivate with correct timings.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "1. Create the React/HTML overlay layer sitting on top of the Phaser canvas.\n2. Bind HUD components (Health, Heat) to Game State stores.\n3. Implement visual overlays for specific states: Sun Damage (red vignette), Panic (flashing borders)."
      },
      {
        "id": "10",
        "title": "MVP-10 Screens S0S10 + Navigation",
        "description": "Implement full UI flow (Splash, Main, Character Select, Castle, Upgrades, Settings, Pause, Death, Credits) using DS components and NavigationController.",
        "details": "Test Strategy: end-to-end navigation flow.",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          "3"
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Setup NavigationController and Routing Logic",
            "description": "Create a central hub to manage screen transitions, history stack, and deep linking for all MVP screens.",
            "dependencies": [],
            "details": "Implement a stack-based router that supports pushing and popping screens while handling platform-specific back button events and lifecycle hooks.",
            "status": "pending",
            "testStrategy": "Verify navigation stack integrity and history management through unit tests and route tracking.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Static UI Screens (Splash, Main, Credits, Settings)",
            "description": "Develop the low-complexity informational screens using existing Design System components.",
            "dependencies": [
              1
            ],
            "details": "Construct the Splash, MainMenu, Credits, and Settings screens ensuring they utilize PixelCard and Button components from the Design System.",
            "status": "pending",
            "testStrategy": "UI smoke tests to ensure layout consistency across different screen sizes and button click navigation.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Interactive Data-Driven Screens (CharacterSelect, Upgrades)",
            "description": "Build screens requiring complex data binding from GameConfig and persistent state mutation for player progression.",
            "dependencies": [
              1,
              2
            ],
            "details": "Integrate CharacterSelect with player stat visualization and the Upgrades screen with stateful logic that updates based on player currency/blood.",
            "status": "pending",
            "testStrategy": "Integration tests to verify that selections in CharacterSelect and purchases in Upgrades persist across navigation sessions.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "End-to-End Navigation Flow and Transition Refinement",
            "description": "Finalize screen transitions for Pause, Death, and Castle screens to ensure a cohesive user experience.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Add animated transitions between states, implement the Pause overlay logic, and hook the Death screen into the core gameplay event system.",
            "status": "pending",
            "testStrategy": "Full end-to-end manual walkthrough of the S0 through S10 screen flow to identify any broken links or transition glitches.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 4,
        "expansionPrompt": "1. Set up a global Router or Screen Manager.\n2. Implement static screens: Splash, MainMenu, Credits, Settings.\n3. Implement complex screens: CharacterSelect (data binding), Upgrades (state mutation).\n4. Ensure cohesive navigation flow (back button handling, transitions)."
      },
      {
        "id": "11",
        "title": "MVP-11 Save + Upgrades",
        "description": "Implement local save for player name, settings, upgrades; upgrades defined in config and exposed in UI.",
        "details": "Test Strategy: persistence round-trip tests.",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          "10"
        ],
        "priority": "medium",
        "subtasks": [],
        "complexity": 4,
        "recommendedSubtasks": 3,
        "expansionPrompt": "1. Define the SaveData schema (JSON serializable).\n2. Implement LocalStorage adapter with save/load/delete methods.\n3. Create the UpgradeManager to apply unlocked modifiers to GameConfig at runtime."
      },
      {
        "id": "12",
        "title": "MVP-12 PWA Minimal",
        "description": "Add manifest.json, icons, and meta tags for installability. No service worker/offline cache.",
        "details": "Test Strategy: installability in Chrome/Safari (manual).",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [],
        "complexity": 2,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Generate manifest and meta tags. Verify icon sizes."
      },
      {
        "id": "13",
        "title": "MVP-13 QA + Acceptance",
        "description": "Expand tests + manual checklist for full MVP acceptance criteria.",
        "details": "Test Strategy: full regression pass.",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [
          "8",
          "9",
          "10",
          "11"
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Write integration tests for critical user flows (Start Game -> Play -> Die -> Restart)",
            "description": "Develop and implement automated integration tests covering the end-to-end gameplay loop and state transitions.",
            "dependencies": [],
            "details": "Focus on logic-layer state transitions and game engine lifecycle events to ensure stability of the core flow across screens without relying purely on UI rendering.",
            "status": "pending",
            "testStrategy": "Automated execution of Vitest/Jest integration suites simulating state changes from initialization to death and restart.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Perform manual acceptance testing against the PRD checklist",
            "description": "Execute a comprehensive manual QA pass following the Product Requirements Document to ensure all features meet defined criteria.",
            "dependencies": [
              1
            ],
            "details": "Verify UI responsiveness, PWA installability, local save persistence, and edge-case behaviors across targeted mobile and desktop browsers.",
            "status": "pending",
            "testStrategy": "Cross-browser manual testing using Chrome and Safari; verification against the master PRD acceptance spreadsheet.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 2,
        "expansionPrompt": "1. Write integration tests for critical user flows (Start Game -> Play -> Die -> Restart).\n2. Perform manual acceptance testing against the PRD checklist."
      },
      {
        "id": "14",
        "title": "MVP-AFTER Doc",
        "description": "Create AFTER_MVP.md with deferred items (PWA offline + cloud sync).",
        "details": "Test Strategy: file exists, content verified.",
        "testStrategy": "",
        "status": "pending",
        "dependencies": [],
        "priority": "low",
        "subtasks": [],
        "complexity": 1,
        "recommendedSubtasks": 0,
        "expansionPrompt": "Compile known tech debt and future features into markdown."
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-02-05T19:46:22.376Z",
      "taskCount": 14,
      "completedCount": 3,
      "tags": [
        "mvp-full"
      ]
    }
  }
}