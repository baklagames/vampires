{
	"meta": {
		"generatedAt": "2026-02-05T14:53:19.211Z",
		"tasksAnalyzed": 14,
		"totalTasks": 14,
		"analysisCount": 14,
		"thresholdScore": 5,
		"projectName": "Task Master",
		"usedResearch": true
	},
	"complexityAnalysis": [
		{
			"taskId": 1,
			"taskTitle": "MVP-01 Config Expansion",
			"complexityScore": 3,
			"recommendedSubtasks": 3,
			"expansionPrompt": "1. Create types/interfaces for the new config sections (Player, NPC, Police, UI, Upgrades).\n2. Update the default YAML file with PRD values.\n3. Implement a schema validation layer (e.g., Zod) to ensure loaded config matches types.",
			"reasoning": "Mostly data entry and type definition. Complexity is low, but validation is critical to prevent runtime errors later."
		},
		{
			"taskId": 2,
			"taskTitle": "MVP-02 DS Tokens v2 + CSS Vars",
			"complexityScore": 4,
			"recommendedSubtasks": 2,
			"expansionPrompt": "1. Define the token registry (JSON/TS) matching the PRD values for colors, spacing, and typography.\n2. Create a utility to inject these tokens as CSS variables into the global stylesheet.",
			"reasoning": "Foundational work. Requires mapping design specs to code. Moderate complexity due to the need for a robust system that feeds into components."
		},
		{
			"taskId": 3,
			"taskTitle": "MVP-03 DS Components",
			"complexityScore": 7,
			"recommendedSubtasks": 6,
			"expansionPrompt": "1. Implement atomic components: Button, Chip, TextField, Toggle.\n2. Implement composite components: PixelCard, ModalSheet, BottomActionBar.\n3. Implement game-specific UI: HealthBar/ProgressBar, HeatIndicator.\n4. Create a Storybook or gallery page to visualize components in isolation.",
			"reasoning": "High volume of work. Implementing 12+ components with states (hover, active, disabled) and ensuring they use the new tokens requires significant effort and testing."
		},
		{
			"taskId": 4,
			"taskTitle": "MVP-04 Core Player Systems",
			"complexityScore": 8,
			"recommendedSubtasks": 5,
			"expansionPrompt": "1. Implement PlayerController class managing state and input handling.\n2. Create FeedingSystem handling interaction radius and 'bite' logic.\n3. Implement SunDamageSystem with raycasting or tile-check logic.\n4. Build HeatController to track suspicion levels and decay over time.\n5. Wire these systems into a testable harness independent of Phaser scenes.",
			"reasoning": "Core gameplay loop. High complexity due to state management, physics/interaction checks, and balancing config values. Logic needs to be decoupled from rendering."
		},
		{
			"taskId": 5,
			"taskTitle": "MVP-05 Detection + NPC AI",
			"complexityScore": 9,
			"recommendedSubtasks": 5,
			"expansionPrompt": "1. Implement Line-of-Sight (LOS) utility handling tilemap collisions.\n2. Create the NPC State Machine (FSM) base class.\n3. Implement specific states: Idle/Wander, Suspicious (investigate), Alarmed (flee/alert).\n4. Create DetectionController to manage awareness cones/circles for NPCs.\n5. Optimize neighbor lookups for NPC-to-NPC communication.",
			"reasoning": "AI behavior is notoriously tricky. LOS calculations can be expensive, and state transitions need to be glitch-free. Highest complexity logic task."
		},
		{
			"taskId": 6,
			"taskTitle": "MVP-06 Panic + Police",
			"complexityScore": 6,
			"recommendedSubtasks": 3,
			"expansionPrompt": "1. Implement 'Panic Bubble' propagation logic (NPCs alerting nearby NPCs).\n2. Create PoliceSpawner logic based on global Heat level.\n3. Implement basic Police AI (chase player) distinct from Civilian AI (flee).",
			"reasoning": "Builds heavily on Task 5. The core complexity is in the propagation algorithm and spawning rules, but the AI movement can reuse existing patterns."
		},
		{
			"taskId": 7,
			"taskTitle": "MVP-07 Maps + Placeholder Assets",
			"complexityScore": 4,
			"recommendedSubtasks": 3,
			"expansionPrompt": "1. Create Tiled tilemaps for Town, Interior, and Castle using placeholder tilesets.\n2. Define collision layers and spawn points in map data.\n3. Create an AssetLoader service to manage map parsing and sprite loading.",
			"reasoning": "Primarily asset production and configuration. Technical complexity is low provided the Phaser map loader is standard."
		},
		{
			"taskId": 8,
			"taskTitle": "MVP-08 Phaser Scene Wrappers",
			"complexityScore": 6,
			"recommendedSubtasks": 4,
			"expansionPrompt": "1. Create BaseScene class to handle common setup (input, resizing).\n2. Implement TownScene, InteriorScene, CastleScene.\n3. Build a SceneTransitionManager to handle fading and data passing between scenes.\n4. Connect the Logic Controllers (Task 4/5) to the Scene update loops.",
			"reasoning": "Glue code. Requires understanding Phaser's lifecycle (preload, create, update) and effectively bridging it with the decoupled game logic."
		},
		{
			"taskId": 9,
			"taskTitle": "MVP-09 HUD + Overlays",
			"complexityScore": 5,
			"recommendedSubtasks": 3,
			"expansionPrompt": "1. Create the React/HTML overlay layer sitting on top of the Phaser canvas.\n2. Bind HUD components (Health, Heat) to Game State stores.\n3. Implement visual overlays for specific states: Sun Damage (red vignette), Panic (flashing borders).",
			"reasoning": "Requires syncing high-frequency game data (60fps) to UI components without performance penalty. React-Phaser bridge is the main complexity."
		},
		{
			"taskId": 10,
			"taskTitle": "MVP-10 Screens S0â€“S10 + Navigation",
			"complexityScore": 5,
			"recommendedSubtasks": 4,
			"expansionPrompt": "1. Set up a global Router or Screen Manager.\n2. Implement static screens: Splash, MainMenu, Credits, Settings.\n3. Implement complex screens: CharacterSelect (data binding), Upgrades (state mutation).\n4. Ensure cohesive navigation flow (back button handling, transitions).",
			"reasoning": "Standard UI development work. Volume is high (10+ screens), but individual complexity is manageable using the components from Task 3."
		},
		{
			"taskId": 11,
			"taskTitle": "MVP-11 Save + Upgrades",
			"complexityScore": 4,
			"recommendedSubtasks": 3,
			"expansionPrompt": "1. Define the SaveData schema (JSON serializable).\n2. Implement LocalStorage adapter with save/load/delete methods.\n3. Create the UpgradeManager to apply unlocked modifiers to GameConfig at runtime.",
			"reasoning": "Persistence logic is straightforward. Ensuring upgrades correctly modify game balance values dynamically is the main logic requirement."
		},
		{
			"taskId": 12,
			"taskTitle": "MVP-12 PWA Minimal",
			"complexityScore": 2,
			"recommendedSubtasks": 0,
			"expansionPrompt": "Generate manifest and meta tags. Verify icon sizes.",
			"reasoning": "Configuration task. Very low complexity using standard templates."
		},
		{
			"taskId": 13,
			"taskTitle": "MVP-13 QA + Acceptance",
			"complexityScore": 5,
			"recommendedSubtasks": 2,
			"expansionPrompt": "1. Write integration tests for critical user flows (Start Game -> Play -> Die -> Restart).\n2. Perform manual acceptance testing against the PRD checklist.",
			"reasoning": "Crucial for stability. Writing good integration tests for canvas-based games is challenging; might rely heavily on logic-layer testing."
		},
		{
			"taskId": 14,
			"taskTitle": "MVP-AFTER Doc",
			"complexityScore": 1,
			"recommendedSubtasks": 0,
			"expansionPrompt": "Compile known tech debt and future features into markdown.",
			"reasoning": "Documentation task only."
		}
	]
}